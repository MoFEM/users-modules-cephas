/*! \page user_data_operators_table User data operators table

\note Work in progress. Tables not complete.

\tableofcontents

Template arguments:

- <b>BASE_DIM</b> is dimension of base function. Typically bases for L2 and
H1 spaces are scalar bases. Thus BASE_DIM is 1. Typically H-div and H-curl
bases are vectorial bases and BASE_DIM 3. For some special case could be
exceptions.

- <b>FIELD_DIM</b> is dimension of the field. We can have scalar filed, vectorial field. For example, the scalar file for scalar base function has one coefficient for base function and \em FIELD_DIM = 1. Vectorial field with scalar based in 3d has three coefficients for each base function and \em FIELD_DIM = 3. On the other hand, a vectorial field with a vectorial base has one coefficient for each base function and \em FIELD_DIM = 3, and tensorial field of rank two in 3d on vectorial base has three coefficients for each base function and \em FIELD_DIM = 9.

- <b>SPACE_DIM</b> is dismension of space. Typically used to indicate how many 
elements have a gradient of base function or field.

- <b>ASSEMBLE_TYPE</b> by this template assembly method is indicated. For example, if the assembly is to CST compressed matrix assembly type is PETSC. For some other cases, for example, integration to nested matrices, or other matrices
formats could be added and implemented.

- <b>INTEGRATION_TYPE</b> indicate method used to assembly elements. If standard numerical integration is used, then the integration type is GAUSS. Some other more sophisticated integration methods can be implemented to exploit some base functions for fast integration.

- <b>%OP</b> type of opetaor for voulme, face, edge or vertex finite element.

\section tab_user_data_op Field operators

<table>
<caption id="user_data_ops_table">Table of user data operators</caption>

<tr><th>Oparator <th> \hiderefs Usage 
<tr>

<td colspan="2">
<b>Scalar fields</b>
<tr>

<td>

Evaulate scalar field at integration points. 
\ref MoFEM::OpCalculateScalarFieldValues 

\f[ u^h(\pmb\xi^g) = \sum_i^N \phi^i(\pmb\xi^g) \overline{u}_i 
\f] 

where \f$u^(\pmb\xi^g)\f$ is value at integration point \f$g\f$,
\f$\phi^i(\pmb\xi^g)\f$ is value of base function \f$i\f$ at integtation point
coordinate \f$\pmb\xi^g\f$, and \f$\overline{u}_i\f$ is \f$i\f$-th degree of
freedom.


This function has similar variant to calulate rates, when time solver is used,
see \ref MoFEM::OpCalculateScalarFieldValuesDot. 

\f[ 
\dot{u}^h
(\pmb\xi^g) = 
\sum_i^N \phi^i(\pmb\xi^g) 
\dot{\overline{u}}_i 
\f]

where \f$\dot{u}^(\pmb\xi^g)\f$ is rate value at integration point \f$g\f$ and \f$\dot{\overline{u}}_i\f$ is rate of \f$i\f$-th degree of freedom. \emph Note that funtio will work only with TS solver.

<td> 

Basic usage:
\code
auto vals_U_at_integration_pts = boost::make_shared<VectorDouble>();
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpCalculateScalarFieldValues("U", vals_U_at_integration_pts));
\endcode

Operatutor for given field calulate valuse of scalar field at integration
points. Values are stored in for example in \em
vals_U_at_integration_pts. Then value can be accessad also
follows
\code 
auto nb_integtation_pts = vals_U_at_integration_pts->size();
auto t_val = getFTensor0FromVec((vals_U_at_integration_pts);
for(auto gg = 0;gg!=nb_integtation_pts;++gg) {
  // do somthing
  ++t_val;
}
\endcode

<tr>

<td>

Evalute scalar field gradinet

\ref MoFEM::OpCalculateScalarFieldGradient

\f[ 
{u}^h_{,j}
(\pmb\xi^g) = 
\sum_i^N \phi^i_{,j}(\pmb\xi^g) 
\dot{\overline{u}}_i 
\f]

where 
\f[
\phi^i_{,j} = \left. \frac{\partial \phi^i}{\partial \xi_j} \right|_{\pmb\xi^g}
\f]

Depending on contect direvatives are calculated in reference element on current phicial elemen. For most of cases usally gradient is acalulated on
current phiscal element. Then direvative of base function is interpreted as

\f[
\phi^i_{,j} = \left. \frac{\partial \phi^i}{\partial \xi_j} \frac{\partial \xi_k}{\partial x_j} \right|_{\mathbf{x}(\pmb\xi^g)}
\f]

<td>

Basic usage:
\code
constexpr int SPACE_DIM = 3;
auto grad_U_at_integration_pts = boost::make_shared<MatrixDouble>();
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpCalculateVectorFieldValues<SPACE_DIM>("U", grad_U_at_integration_pts));
\endcode


Operatutor for given field calulate valuse of scalar field gradient at integration points. Values are stored in for example in \em
grad_U_at_integration_pts. Then value can be accessad also
follows
\code 
constexpr int FIELD_DIM = 3;
FTensor::Index<'i', FIELD_DIM> i; 
auto nb_integtation_pts = grad_U_at_integration_pts->size2();
auto t_grad = getFTensor1FromMat<FIELD_DIM>((grad_U_at_integration_pts);
for(auto gg = 0;gg!=nb_integtation_pts;++gg) {
  auto dot = t_grad(i)*t_grad(i);
  ++t_grad;
}
\endcode

<tr>

<td colspan="2">
<b>Vector fields</b>
<tr>

<td>
Evaluate vector field at integration points
\ref MoFEM::OpCalculateVectorFieldValues

\f[ 
u_j^h(\pmb\xi^g) = \sum_i^N \phi^i(\pmb\xi^g) 
\overline{u}_i^j
\f]
where \f$j\f$ is vector element index.

This function has similar variant to calulate rates, when time solver is used,
see \ref MoFEM::OpCalculateVectorFieldValuesDot, which can be used with 
time solver (TS). Also is variant to calulate accelartions, \ref MoFEM::OpCalculateVectorFieldValuesDotDot, which can be used with second order time solver (TS2). Petsc has currently implemented alpha method for second order
time differntial equations.

<td>

Basic usage:
\code
constexpr int FIELD_DIM = 3;
auto vals_U_at_integration_pts = boost::make_shared<MatrixDouble>();
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpCalculateVectorFieldValues<FIELD_DIM>("U", vals_U_at_integration_pts));
\endcode

Operatutor for given field calulate valuse of vector field at integration
points. Values are stored in for example in \em
vals_U_at_integration_pts. Then value can be accessad also
follows
\code 
constexpr int FIELD_DIM = 3;
FTensor::Index<'i', FIELD_DIM> i; 
auto nb_integtation_pts = vals_U_at_integration_pts->size2();
auto t_val = getFTensor1FromMat<FIELD_DIM>((vals_U_at_integration_pts);
for(auto gg = 0;gg!=nb_integtation_pts;++gg) {
  auto dot = t_val(i)*t_val(i);
  ++t_val;
}
\endcode

<tr>

<td>
Evaluate vector field gradient at integration points
\ref MoFEM::OpCalculateVectorFieldGradient

\f[ 
u_{jk}^h(\pmb\xi^g) = \sum_i^N \phi^i_{,k}(\pmb\xi^g) 
\overline{u}_i^{j}
\f]
where \f$j\f$ is vector element index, \f$k\f$ is derivative and \f$i\f$ is index of base function.

This function has similar variant to calulate rates, when time solver is used,
see \ref MoFEM::OpCalculateVectorFieldGradientDot, which can be used with 
time solver (TS).

<td>

Basic usage:
\code
constexpr int FIELD_DIM = 3;
constexpr int SPACE_DIM = 3;
auto grad_U_at_integration_pts = boost::make_shared<MatrixDouble>();
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpCalculateVectorFieldGradient<FIELD_DIM, SPACE_DIM>("U", grad_U_at_integration_pts));
\endcode

Operatotor for given field calulate gradien of vector field at integration
points. Values are stored in for example in \em
grad_U_at_integration_pts. Then value can be accessad also
follows
\code 
constexpr int FIELD_DIM = 3;
constexpr int SPACE_DIM = 3;
FTensor::Index<'i', FIELD_DIM> i; 
FTensor::Index<'j', SPACE_DIM> j; 
constexpr auto t_kd = FTensor::Kronecker_Delta<double>();
auto nb_integtation_pts = vals_U_at_integration_pts->size2();
auto t_grad = getFTensor2FromMat<FIELD_DIM, SPACE_DIM>((grad_U_at_integration_pts);
for(auto gg = 0;gg!=nb_integtation_pts;++gg) {
  auto trace = t_grad(i,j)*t_kd(i,j);
  ++t_grad;
}
\endcode

<tr>

<td colspan="2">
<b>Tensor fields</b>
<tr>

<td>
Evaluate tensor field at integration points
\ref MoFEM::OpCalculateTensor2FieldValues

\f[ 
u_{jk}^h(\pmb\xi^g) = \sum_i^N \phi^i(\pmb\xi^g) 
\overline{u}_i^{jk}
\f]
where \f$j\f$ and \f$j\f$ tensor element (coefficient) indices.

This function has similar variant to calulate rates, when time solver is used,
see \ref MoFEM::OpCalculateTensor2FieldValuesDot, which can be used with 
time solver (TS). 

<td>

Basic usage:
\code
constexpr int FIELD_DIM = 3;
auto vals_U_at_integration_pts = boost::make_shared<MatrixDouble>();
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpCalculateTensor2FieldValues<FIELD_DIM, FIELD_DIM>("U", vals_U_at_integration_pts));
\endcode

Operatutor for given field calulate valuse of tensor field at integration
points. Values are stored in for example in \em
vals_U_at_integration_pts. Then value can be accessad also
follows
\code 
constexpr int FIELD_DIM = 3;
FTensor::Index<'i', FIELD_DIM> i; 
FTensor::Index<'j', FIELD_DIM> j; 
auto nb_integtation_pts = vals_U_at_integration_pts->size2();
auto t_val = getFTensor2FromMat<FIELD_DIM, FIELD_DIM>((vals_U_at_integration_pts);
for(auto gg = 0;gg!=nb_integtation_pts;++gg) {
  auto norm = sqrt(t_val(i,j)*t_val(i,j));
  ++t_val;
}
\endcode

<tr>

<td>
Evaluate \em symmetric tensor field at integration points
\ref MoFEM::OpCalculateTensor2SymmetricFieldValues

\f[ 
u_{jk}^h(\pmb\xi^g) = \sum_i^N \phi^i(\pmb\xi^g) 
\overline{u}_i^{jk}
\f]
where \f$j\f$ and \f$j\f$ tensor element (coefficient) indices.

Note that field degrees of freedom represnts only symmetric coeefcients, so for each base funtion we have number of DOFs given by fromula (FIELD_DIM * (FIELD_DIM + 1)) / 2. For example for 3d case, six DOFs for each base function.  

This function has similar variant to calulate rates, when time solver is used,
see \ref MoFEM::OpCalculateTensor2SymmetricFieldValuesDot, which can be used with time solver (TS). 

<td>

Basic usage:
\code
constexpr int FIELD_DIM = 3;
auto vals_U_at_integration_pts = boost::make_shared<MatrixDouble>();
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpCalculateTensor2SymmetricFieldValues<FIELD_DIM>("U", vals_U_at_integration_pts));
\endcode

Operatutor for given field calulate valuse of tensor field at integration
points. Values are stored in for example in \em
vals_U_at_integration_pts. Then value can be accessad also
follows
\code 
constexpr int FIELD_DIM = 3;
FTensor::Index<'i', FIELD_DIM> i; 
FTensor::Index<'j', FIELD_DIM> j; 
auto nb_integtation_pts = vals_U_at_integration_pts->size2();
auto t_val = getFTensor2SymmetricFromMat<FIELD_DIM>((vals_U_at_integration_pts);
for(auto gg = 0;gg!=nb_integtation_pts;++gg) {
  auto norm = sqrt(t_val(i,j)*t_val(i,j));
  ++t_val;
}
\endcode

<tr>

</table>

\note User data operators are defined in file \ref UserDataOperators.hpp

\section tab_other_data_op Other operators


<table>
<caption id="user_other_ops_table">Table of other operators</caption>

<tr>
<th>Oparator <th> \hiderefs Usage 
<tr>

<td>
Calualte inverse jacobian on face

\ref MoFEM::OpCalculateInvJacForFace

<td>
Example usage
\code
MatrixDouble jac(2, 2);
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpCalculateInvJacForFace(inv_jac));
\endcode
<tr>

</table>

\note User data operators are defined in file \ref UserDataOperators.hpp

\section tab_linear_forms Linear forms

<table>
<caption id="user_linear_forms_ops_table">Table of linear from operators</caption>

<tr><th>Oparator <th> \hiderefs Usage 
<tr>

<td>

Integrate fource term for scalar and vectorial fields

\ref MoFEM::OpSourceImpl

\f[
(v_i,f_i(\mathbf{x}))_\Omega =
\int_\Omega v_i f_i (x,y,z) 
\textrm{d}\Omega
\f]

Template arguments:
\code
using OpSource = 
  FormsIntegrators<OP>::
  Assembly<ASSEMBLE_TYPE>::
  LinearForm<INTEGRATION_TYPE>::
  OpSource<BASE_DIM, FIELD_DIM>;
\endcode

<td>

%Example usage for scalar base and scalar field:
\code
using OpDomainSource = FormsIntegrators<DomainEleOp>::Assembly<
    PETSC>::LinearForm<GAUSS>::OpSource<1, 1>;
auto fun = [](double x, double y, double z) {
  return sin(x/L)*siz(y/L)*siz(z/L);
};
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpDomainSource("U", fun));
\endcode

%Example usage for scalar base and vector field:
\code
using OpDomainSource = FormsIntegrators<DomainEleOp>::Assembly<
    PETSC>::LinearForm<GAUSS>::OpSource<1, 3>;
auto fun = [](double x, double y, double z) {
  return FTensor::Tensor1<double>{ sin(x/L), sin(y/L), sin(z/L) };
};
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpDomainSource("U", fun));
\endcode

%Example usage for vector base and vector field:
\code
using OpDomainSource = FormsIntegrators<DomainEleOp>::Assembly<
    PETSC>::LinearForm<GAUSS>::OpSource<3, 3>;
auto fun = [](double x, double y, double z) {
  return FTensor::Tensor1<double>{ sin(x/L), sin(y/L), sin(z/L) };
};
pipeline_mng->getOpDomainRhsPipeline().push_back(
  new OpDomainSource("U", fun));
\endcode


<tr>

</table>

\note Linear froms are defined in file LinearFormsIntegrators.hpp

\section tab_bilinear_forms Bilinear forms

<table>
<caption id="user_bilinear_forms_ops_table">Table of bilinear from operators</caption>

<tr><th>Oparator <th> \hiderefs Usage 
<tr>

<td>
Integrate Grad Grad operator

\ref MoFEM::OpGradGradImpl

\code
using OpDomainGradGrad = 
  FormsIntegrators<OP>::Assembly<
  ASSEMBLY_TYPE>::
  BiLinearForm<INTEGRATION_TYPE>::
  OpGradGrad<BASE_DIM, FIELD_DIM, SPACE_DIM>;
\endcode

<td>

Example for scalar base, scalar field and 3d problem
\code
auto beta = [](double x, double y , double z) {
  return 1;
};
using OpDomainGradGrad = FormsIntegrators<DomainEleOp>::Assembly<
    PETSC>::BiLinearForm<GAUSS>::OpGradGrad<1, 1, 3>;
pipeline_mng->getOpDomainLhsPipeline().push_back(
      new OpDomainGradGrad("U", "U", beta));
\endcode
<tr>


</table>

\note Linear froms are defined in file BiLinearFormsIntegrators.hpp

*/
/*! \page basic_tutorials_poisson_nonhomogeneous SCL-2: Poisson's equation (non-homogeneous BC)

\note Prerequisite of this tutorial is \ref basic_tutorials_poisson_homogeneous

<br>

\note Intended learning outcome:
- idea of Boundary element in MoFEM and how to use it
- handling of non-homogeneous boundary condition using least square approximation in MoFEM
- process of implementing additional User Data Operators (UDOs) to calculate and assemble non-homogeneous boundary condition
- practising on how to **push** the developed UDOs to the *Pipeline*


\tableofcontents
\section basic_tutorials_poisson_nonhomogeneous_introduction Introduction

The focus of our current tutorial is on solving partial differential equations (PDEs) incorporating non-homogeneous Poisson's problem with non homogenous Dirichlet boundary conditions. While the 'SCL-1: Poisson's equation (homogeneous BC)' is designed for solving Dirichlet problems with homogeneous boundary conditions. This  tutuorial guides the methods to extend this to non-homogeneous cases. Here, the conditions refer to scenarios  where the solution has to coincide with a given function on the domain's boundary. The primary objective is to present MoFEM approaches for handling non-homogeneous Dirichlet problems integrating least square approximation, while establishing the necessary foundation as well. However, we would like to strictly suggest to undertand the operators(i.e. OpDomainLhsMatrixK and OpDomainRhsVectorF ) in SCL-1: Poisson's equation (homogeneous BC) before proceeding to this tutorial. 

\subsection basic_tutorials_poisson_nonhomogeneous_problem Problem

 In the context, for partial differential equations (PDEs), boundary conditions are added to establish unique solution. Numerous PDEs arise from physical situations where the behavior of the unknown function can be prescribed or observed on the boundary and the corresponding PDEs are equipped with appropriate boundary conditions. In this tutorial, we are solving a simple solution to let you understand the aproch. We are considering, the conditions over the boundary and encompass the followings where \f$\Omega\f$ is the domain, \f$\Gamma\f$ is the dirchilet boundary as in figure 1. 

Here, we want to solve the problem to find the scalar field u such that:

Domain constraint:
\f[
  \begin{align}
  -\nabla \cdot\nabla u = f(\mathbf{x}) \,\,\, in \,\,\, \Omega 
  \end{align}
\f]
 Here, f is the body source term on the domain and the boundary condition,

\f[
  \begin{align}
  U_g = g(\mathbf{x}) \,\,\, on \,\,\,\Gamma
  \end{align}
\f]

In particular, if g = 0, we speak of homogeneous boundary conditions. But in this problem we are considering funcion \f$g(\mathbf{x})\f$.
\anchor figure_poisson_nonhomogeneous_problem
\image html poisson_nonhomogeneous_problem.png "Figure 1: Nonhomogeneous problem Statement. " width = 300px

To know about discretization, it is also recomemded to get the idea from SCL-1: Poisson's equation (homogeneous BC).Here the solution is u where \f$ U_g \in u\f$ and \f$\delta u \f$ is the test function where, 
\f[
\begin{align}
\mathbf{u} &= \sum_{i=0}^{P-1} \mathbf{N}_i \bar{u}_i \,\text{and,}\\
{\delta u} &= \sum_{j=0}^{P-1}\mathbf{N}_j \bar{u}_j
\end{align}
\f]

\section basic_tutorials_poisson_nonhomogeneous_numercial_scheme Numerical Scheme
In the context of solving this partial differential equation (PDE), the approach employed is the method of Galerkin finite element methods with least square approximation for solving the nonhomogenous boundary. In addition to that, we are utilizing it conforming finite element spaces. The objective of this formulation is to identify the solution that satisfies the given conditions \f$U_g = g(\bf x)\f$. 

We are considering \f$ H^1(\Omega)\f$ space that fulfill the Dirichlet boundary condition \f$U_g\f$. For better understanding the MoFEM implementation, we are explaining the forms in two parts: domain and boundary where,
\f[
\mathbf{A_k} =
\int_{\Omega} \nabla \delta u \cdot \nabla u  d\Omega\, \quad
\mathbf{B_f} = \int_{\Omega} \nabla \delta u \cdot \nabla u \,\textrm{d}\Gamma\quad for\,\ domain, \\
\text{&} \\
\mathbf{C_k} = \int_{\Omega} \delta u \,\ f(\mathbf{x})\, d\Omega\quad
\mathbf{D_f} = \int_{\Omega} \delta u \,\ f(\mathbf{x})\,d\Gamma \quad for \,\ boundary.
\f]

The problem will be solved numerically by approximating the scalar spaces \f$u\f$ and \f$v\f$ by their discrete counterparts associated with our FE mesh of the computational domain \f$\Omega\f$. The discretisation anf implementation approch is similar as discussed in SCL-1: Poisson's equation (homogeneous BC).

\section basic_tutorials_poisson_nonhomogeneous_problem_fomlation Problem formulation

Based on the above schemes,  we need to create 4 operators in MoFEM. Lets say we are naming those as follows: 
<CENTER>
<STRONG>
<caption> Table 1: Operators for Domain and Boundary for relavent expresions</caption>
</STRONG>
<table>
<tr>
  <th>Respective Operators</th>
<tr>
  <td>\f$\mathbf{A_k} \text{is implemented in } \text{OpDomainLhs}\f$</td>
</tr>
<tr>
  <td>\f$\mathbf{B_f} \text{is implemented in } \text{OpDomainRhs}\f$</td>
</tr>
<tr>
  <td>\f$\mathbf{C_k} \text{is implemented in } \text{OpBoundaryLhs}\f$</td>
</tr>
<tr>
  <td>\f$\mathbf{D_f} \text{is implemented in } \text{OpBoundaryRhs}\f$</td>
</tr>
</table>

</CENTER>

The numerical scheme has several similarities with SCL-1: Poisson's equation (homogeneous BC) in terms of coding in MOFEM. Therefore, we are mostly forwarding to discuss the crtical parts of it. So, in the next section we are discuusing the mazor parts of the code in referenceing to SCL-1: Poisson's equation (homogeneous BC). 

\section basic_tutorials_poisson_nonhomogeneous_coding_strucrure Coding Structure
Before we explore the implementation details of the User-Defined Operators (UDOs) in "poisson_2d_nonhomogeneous.hpp," let's take a look at the initial lines of code in the file. These lines include library inclusions for finite element functionality, alias definitions, and commented steps for declaration and initialization. 

Here we are going to newly introduce dimension wise element types in MoFEM. 
\code
// Define file name if it has not been defined yet
#ifndef __POISSON2DNONHOMOGENEOUS_HPP__
#define __POISSON2DNONHOMOGENEOUS_HPP__

// Include standard library and Header file for basic finite elements
// implementation
#include <stdlib.h>
#include <BasicFiniteElements.hpp>

// Use of alias for some specific functions
// We are solving Poisson's equation in 2D so Face element is used
using FaceEle = MoFEM::FaceElementForcesAndSourcesCore;
using EdgeEle = MoFEM::EdgeElementForcesAndSourcesCore;

using OpFaceEle = MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator;
using OpEdgeEle = MoFEM::EdgeElementForcesAndSourcesCore::UserDataOperator;

using EntData = EntitiesFieldData::EntData;
// Namespace that contains necessary UDOs, will be included in the main program
namespace Poisson2DNonhomogeneousOperators {

// Declare FTensor index for 2D problem
FTensor::Index<'i', 2> i;
//declare a lamda function 
typedef boost::function<double(const double, const double, const double)>
    ScalarFunc;

//.. .. Implementation of the UDOs below this point .. ..
\endcode

\subsection basic_tutorials_poisson_nonhomogeneous_UDOs User Defined Operators
First, let's look at the structure of UDOs. Users can also learn a general structure of any UDOs implemented in MoFEM. For example, we can notice that our OpDomainLhs is similaar to the OpDomainLhsMatrixK operator in SCL-1: Poisson's equation (homogeneous BC). However, Lets identify the differences bellow and then the further difference will be discussed: 
\subsubsection OpDomainRhs OpDomainLhs()
\code
struct OpDomainLhs : public OpFaceEle {
public:
  OpDomainLhs(std::string row_field_name, std::string col_field_name)
      : OpFaceEle(row_field_name, col_field_name, OpFaceEle::OPROWCOL) {
    sYmm = true;
  }

  MoFEMErrorCode doWork(int row_side, int col_side, EntityType row_type,
                        EntityType col_type, EntData &row_data,
                        EntData &col_data) {
    MoFEMFunctionBegin;

    const int nb_row_dofs = row_data.getIndices().size();
    const int nb_col_dofs = col_data.getIndices().size();

    if (nb_row_dofs && nb_col_dofs) {

      locLhs.resize(nb_row_dofs, nb_col_dofs, false);
      locLhs.clear();

      // get element area
      const double area = getMeasure();

      // get number of integration points
      const int nb_integration_points = getGaussPts().size2();
      // get integration weights
      auto t_w = getFTensor0IntegrationWeight();

      // get derivatives of base functions on row
      auto t_row_diff_base = row_data.getFTensor1DiffN<2>();

      // START THE LOOP OVER INTEGRATION POINTS TO CALCULATE LOCAL MATRIX
      for (int gg = 0; gg != nb_integration_points; gg++) {

        const double a = t_w * area;

        for (int rr = 0; rr != nb_row_dofs; ++rr) {
          // get derivatives of base functions on column
          auto t_col_diff_base = col_data.getFTensor1DiffN<2>(gg, 0);

          for (int cc = 0; cc != nb_col_dofs; cc++) {

            locLhs(rr, cc) += t_row_diff_base(i) * t_col_diff_base(i) * a;

            // move to the derivatives of the next base functions on column
            ++t_col_diff_base;
          }

          // move to the derivatives of the next base functions on row
          ++t_row_diff_base;
        }

        // move to the weight of the next integration point
        ++t_w;
      }

      // FILL VALUES OF LOCAL MATRIX ENTRIES TO THE GLOBAL MATRIX

      // Fill value to local stiffness matrix ignoring boundary DOFs
      CHKERR MatSetValues<MoFEM::EssentialBcStorage>(
          getKSPB(), row_data, col_data, &locLhs(0, 0), ADD_VALUES);

      // Fill values of symmetric local stiffness matrix
      if (row_side != col_side || row_type != col_type) {
        transLocLhs.resize(nb_col_dofs, nb_row_dofs, false);
        noalias(transLocLhs) = trans(locLhs);
        CHKERR MatSetValues<MoFEM::EssentialBcStorage>(
            getKSPB(), col_data, row_data, &transLocLhs(0, 0), ADD_VALUES);
      }
    }

    MoFEMFunctionReturn(0);
  }

private:
  boost::shared_ptr<std::vector<unsigned char>> boundaryMarker;
  MatrixDouble locLhs, transLocLhs;
};
\endcode

In the above, the class OpDomainLhs is inherited from OpFaceEle, which stands as the alias for the base class MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator. Within this class, there stands two public entities: OpDomainLhs() and doWork(). Here, the doWork() does the same as iNtegrate as in SCL-1: Poisson's equation (homogeneous BC). However, the difference is that we are using a different lamda function to calculate the body source term. Alongside, we have got two private members named locLhs and transLocLhs. This follows the concept of data encapsulation to hide values and objects inside the class as much as possible.

- `locLhs` <br>
This private member object of type MatrixDouble is used to store the results of the calculation of components of element stiffness matrix. Besides, this object is made private so that only member of the class know how to use it because  members from other classes have no access to this private object avoiding unpredictable consequences, i.e. errors.
- `transLocLhs` <br>
This private member object also of type MatrixDouble is used to assemble the transpose of locLhs. This object is used only in function doWork() so it is also declared as a private object of the class OpDomainLhs.
- `CHKERR MatSetValues` <br> 
The coding part is as follows:
\code 
   CHKERR MatSetValues<MoFEM::EssentialBcStorage>(
          getKSPB(), row_data, col_data, &locLhs(0, 0), ADD_VALUES);

      // Fill values of symmetric local stiffness matrix
      if (row_side != col_side || row_type != col_type) {
        transLocLhs.resize(nb_col_dofs, nb_row_dofs, false);
        noalias(transLocLhs) = trans(locLhs);
        CHKERR MatSetValues<MoFEM::EssentialBcStorage>(
            getKSPB(), col_data, row_data, &transLocLhs(0, 0), ADD_VALUES);
\endcode
The function MatSetValues() is used to assemble the global matrix. This function sets values for the global matrix using inputs like getKSPB(), row_data, col_data, and the memory address of the local stiffness matrix's  and also first component &locLhs(0, 0). The ADD_VALUES flag is used to add values during the assembly. Transposing is performed for the symmetric global matrix  which is then solved using the iterative solver linear KSP.

\subsubsection OpDomainRhs OpDomainRhs()
The characterization of OpDomainRhs is straightforward and aligns with OpDomainRhsVectorF in the context of SCL-1 for solving Poisson's equation with homogeneous boundary conditions. However, there is a slightly difference in the body source term. The accompanying code snippet illustrates in the following:
\code
struct OpDomainRhs : public OpFaceEle {
public:
  OpDomainRhs(std::string field_name, ScalarFunc source_term_function)
      : OpFaceEle(field_name, OpFaceEle::OPROW),
        sourceTermFunc(source_term_function) {}

  MoFEMErrorCode doWork(int side, EntityType type, EntData &data) {
    MoFEMFunctionBegin;

    const int nb_dofs = data.getIndices().size();

    if (nb_dofs) {

      locRhs.resize(nb_dofs, false);
      locRhs.clear();

      // get element area
      const double area = getMeasure();

      // get number of integration points
      const int nb_integration_points = getGaussPts().size2();
      // get integration weights
      auto t_w = getFTensor0IntegrationWeight();
      // get coordinates of the integration point
      auto t_coords = getFTensor1CoordsAtGaussPts();

      // get base functions
      auto t_base = data.getFTensor0N();

      // START THE LOOP OVER INTEGRATION POINTS TO CALCULATE LOCAL VECTOR
      for (int gg = 0; gg != nb_integration_points; gg++) {

        const double a = t_w * area;
        double body_source =
            sourceTermFunc(t_coords(0), t_coords(1), t_coords(2));

        for (int rr = 0; rr != nb_dofs; rr++) {

          locRhs[rr] += t_base * body_source * a;

          // move to the next base function
          ++t_base;
        }

        // move to the weight of the next integration point
        ++t_w;
        // move to the coordinates of the next integration point
        ++t_coords;
      }

      // FILL VALUES OF THE GLOBAL VECTOR ENTRIES FROM THE LOCAL ONES
      CHKERR VecSetValues<MoFEM::EssentialBcStorage>(
          getKSPf(), data, &*locRhs.begin(), ADD_VALUES);
    }

    MoFEMFunctionReturn(0);
  }

private:
  ScalarFunc sourceTermFunc;
  VectorDouble locRhs;
};
\endcode
 In the above, we can see a different body source term which is calculted by calling a lamda function sourceTermFunc() with coordinate(x, y, z) coordinates t_coords(0), t_coords(1), and t_coords(2) as arguments as follows: 
\code 
double body_source =
            sourceTermFunc(t_coords(0), t_coords(1), t_coords(2));

        for (int rr = 0; rr != nb_dofs; rr++) {

          locRhs[rr] += t_base * body_source * a;

          // move to the next base function
          ++t_base;
        }
\endcode

\subsubsection OpBoundaryLhs OpBoundaryLhs()
This operator is quite similar to our first operator, OpDomainLhs. Therefore we are not describing again. However, OpBoundaryLhs is focusing on the boundary(\f$ \Gamma\f$) instead of the domain. So we're using OpEdgeEle instead of OpFaceEle. You can realize the fact easily that for 2D problem any boundary element type is edge(1D) and for 3D problem it will be face(2D) type element.

\subsubsection OpBoundaryRhs OpBoundaryRhs()
If we compare OpBoundaryRhs operator, it closely resembles the OpDomainRhsVectorF operator in its structure.Additionally, it is also similar to OpBoundaryRhs. However, we are now using boundary_term here instead of body_source as follows: 
\code
       double boundary_term =
            boundaryFunc(t_coords(0), t_coords(1), t_coords(2));

        for (int rr = 0; rr != nb_dofs; rr++) {

          locBoundaryRhs[rr] += t_base * boundary_term * a;

          // move to the next base function
          ++t_base;
        }
\endcode

\subsection basic_tutorials_poisson_nonhomogeneous_source_code  Main program (*.cpp)
This main class Poisson2DNonhomogeneous contains functions and each of which is responsible for a certain task as decribed in SCL-1. However, in this case we need to delclare two global variable of `sourceTermFunction` and `boundaryFunction`. These function are applicable for the operators OpDomainRhs and OpBoundaryRhs respectively. In addition to that, we have declared a vector type shared pointer 'boundaryMarker'. We will disccuss on it at the description of applying the boundary condition. The code snippet is as follows: 
\code
struct Poisson2DNonhomogeneous {
public:
  Poisson2DNonhomogeneous(MoFEM::Interface &m_field);

  // Declaration of the main function to run analysis
  MoFEMErrorCode runProgram();

private:
  // Declaration of other main functions called in runProgram()
  MoFEMErrorCode readMesh();
  MoFEMErrorCode setupProblem();
  MoFEMErrorCode boundaryCondition();
  MoFEMErrorCode assembleSystem();
  MoFEMErrorCode setIntegrationRules();
  MoFEMErrorCode solveSystem();
  MoFEMErrorCode outputResults();

  // Function to calculate the Source term
  static double sourceTermFunction(const double x, const double y,
                                   const double z) {
    return 200 * sin(x * 10.) * cos(y * 10.);
    // return 1;
  }
  // Function to calculate the Boundary term
  static double boundaryFunction(const double x, const double y,
                                 const double z) {
    return sin(x * 10.) * cos(y * 10.);
    // return 0;
  }

  // Main interfaces
  MoFEM::Interface &mField;
  Simple *simpleInterface;

  // Field name and approximation order
  std::string domainField;
  int oRder;

  // Object to mark boundary entities for the assembling of domain elements
  boost::shared_ptr<std::vector<unsigned char>> boundaryMarker;

  // Boundary entities marked for fieldsplit (block) solver - optional
  Range boundaryEntitiesForFieldsplit;
};
\endcode
subsubsection readMesh readMesh()
Next, to read the mesh the function similar job as in MoFEMErrorCode Poisson2DNonhomogeneous::readMesh().
\code
MoFEMErrorCode Poisson2DNonhomogeneous::readMesh() {
  MoFEMFunctionBegin;

  CHKERR mField.getInterface(simpleInterface);
  CHKERR simpleInterface->getOptions();
  CHKERR simpleInterface->loadFile();

  MoFEMFunctionReturn(0);
}
\endcode

\subsubsection setupProblem setupProblem()
 To setup the problemm, we need to include the field in our problem. Since we are considering both domain and boundary , so we have to aadd the domain and boundary field in the simpleInterface. Besides, we use methods like AINSWORTH_BERNSTEIN_BEZIER_BASE and H1 scalar space, where each shape function has 1 degree of freedom.
\code
MoFEMErrorCode Poisson2DNonhomogeneous::setupProblem() {
  MoFEMFunctionBegin;

  CHKERR simpleInterface->addDomainField(domainField, H1,
                                         AINSWORTH_BERNSTEIN_BEZIER_BASE, 1);
  CHKERR simpleInterface->addBoundaryField(domainField, H1,
                                           AINSWORTH_BERNSTEIN_BEZIER_BASE, 1);

  int oRder = 3;
  CHKERR PetscOptionsGetInt(PETSC_NULL, "", "-order", &oRder, PETSC_NULL);
  CHKERR simpleInterface->setFieldOrder(domainField, oRder);

  CHKERR simpleInterface->setUp();

  MoFEMFunctionReturn(0);
}
\ endcode

\subsubsection boundaryCondition boundaryCondition()
Next, we need to discuss the detail for setting up boundary condition. This code involves marking degrees of freedom on boundary entities, merging markers, and obtaining entities for field splitting. Here is the code snippet in in the following: 
\code
 MoFEMErrorCode Poisson2DNonhomogeneous::boundaryCondition() {
  MoFEMFunctionBegin;

  auto bc_mng = mField.getInterface<BcManager>();
  CHKERR bc_mng->pushMarkDOFsOnEntities(simpleInterface->getProblemName(),
                                        "BOUNDARY_CONDITION", domainField, 0, 1,
                                        true);

  // merge markers from all blocksets "BOUNDARY_CONDITION"
  boundaryMarker =
      bc_mng->getMergedBlocksMarker({"BOUNDARY_CONDITION"});
  // get entities on blocksets "BOUNDARY_CONDITION"
  boundaryEntitiesForFieldsplit =
      bc_mng->getMergedBlocksRange({"BOUNDARY_CONDITION"});

  MoFEMFunctionReturn(0);
} 
\endcode
Here, the line bc_mng->pushMarkDOFsOnEntities(...) is used to push the degrees of freedom (DOFs) onto entities only for marked blockset("BOUNDARY_CONDITION") . Then the blockset are accumulated as in container and assigned as a vector in boundaryMarker. The boundaryEntitiesForFieldsplit is to get the range/ IDs for the blocks including vertex, edges or faces. This is done to indicate the difference between the domain and boundary entities.


\subsubsection assembleSystem assembleSystem()
Now, our attention should be directed towards on MoFEMErrorCode Poisson2DNonhomogeneous::assembleSystem(). Because there is significant changes that happens comparing with the homogenous problem-SCL-1. Before going to that, first we add operators to the OpDomainLhsPipeline using the AddHOOps function considering scalar space H1. Then we need to set the boundary conditions using OpSetBc for domain, then push the main OpDomainLhs operator, and finally unset the boundary conditions using OpUnSetBc. We will discuss on it in detail after going through the the code snippet in the following:
\code
MoFEMErrorCode Poisson2DNonhomogeneous::assembleSystem() {
  MoFEMFunctionBegin;

  auto pipeline_mng = mField.getInterface<PipelineManager>();

  { // Push operators to the Pipeline that is responsible for calculating LHS of
    // domain elements
    CHKERR AddHOOps<SPACE_DIM, SPACE_DIM, SPACE_DIM>::add(
        pipeline_mng->getOpDomainLhsPipeline(), {H1});
    pipeline_mng->getOpDomainLhsPipeline().push_back(
        new OpSetBc(domainField, true, boundaryMarker));
    pipeline_mng->getOpDomainLhsPipeline().push_back(
        new OpDomainLhs(domainField, domainField));
    pipeline_mng->getOpDomainLhsPipeline().push_back(
        new OpUnSetBc(domainField));
  }

  { // Push operators to the Pipeline that is responsible for calculating RHS of
    // domain elements
    pipeline_mng->getOpDomainRhsPipeline().push_back(
        new OpSetBc(domainField, true, boundaryMarker));
    pipeline_mng->getOpDomainRhsPipeline().push_back(
        new OpDomainRhs(domainField, sourceTermFunction));
    pipeline_mng->getOpDomainRhsPipeline().push_back(
        new OpUnSetBc(domainField));
  }

  { // Push operators to the Pipeline that is responsible for calculating LHS of
    // boundary elements
    pipeline_mng->getOpBoundaryLhsPipeline().push_back(
        new OpSetBc(domainField, false, boundaryMarker));
    pipeline_mng->getOpBoundaryLhsPipeline().push_back(
        new OpBoundaryLhs(domainField, domainField));
    pipeline_mng->getOpBoundaryLhsPipeline().push_back(
        new OpUnSetBc(domainField));
  }

  { // Push operators to the Pipeline that is responsible for calculating RHS of
    // boundary elements
    pipeline_mng->getOpBoundaryRhsPipeline().push_back(
        new OpSetBc(domainField, false, boundaryMarker));
    pipeline_mng->getOpBoundaryRhsPipeline().push_back(
        new OpBoundaryRhs(domainField, boundaryFunction));
    pipeline_mng->getOpBoundaryRhsPipeline().push_back(
        new OpUnSetBc(domainField));
  }

  MoFEMFunctionReturn(0);
}
\endcode

Here, the set of process involves using the OpSetBc, OpUnSetBc, and primary operators to push back to the pipeline for assemblying the operators. Specifically, these operations are being carried out on the OpDomainLhsPipeline and OpBoundaryLhsPipeline for both domain and boundary respectively in the same way. So we are only describing for only one set of assemble process in the following: 

The new OpSetBc() function is responsible for assigning memory to the indices for the entities based on the provided 'boundaryMarker'. If it is flagged 'true', to have a different the indexing to the boundary entities. So that the DoFs associated with the specified 'boundaryMarker' can included in the assembly process. This is how, it focuses exclusively on the domain entities and does not account for boundary entities tagged with the 'boundaryMarker.

Then it reapeats the same operation for OpDomainLhs.



\code
{ // Push operators to the Pipeline that is responsible for calculating LHS of
    // domain elements
    CHKERR AddHOOps<SPACE_DIM, SPACE_DIM, SPACE_DIM>::add(
      pipeline_mng->getOpDomainLhsPipeline(), {H1});

    pipeline_mng->getOpDomainLhsPipeline().push_back(
        new OpSetBc(domainField, true, boundaryMarker));
    pipeline_mng->getOpDomainLhsPipeline().push_back(
        new OpDomainLhs(domainField, domainField));
    pipeline_mng->getOpDomainLhsPipeline().push_back(
        new OpUnSetBc(domainField));
  }
\endcode

For boundary, we will follow a similar approach separately. Use OpSetBc(), then add OpBoundaryLhs and OpUnSetBc to the getOpBoundaryLhsPipeline(). However, in this scenario, it's important to set a flag as`false`. Beacuse we dont need to replace any DoFs further.  So, it push for the boundaries which were marked 0 before during the OpUnSetBc.

<BLOCKQUOTE>
To recapitulate, OpSetBc() works for to skipping(marked 'true' to skip) the boundary entities when solving for domain. On the other hand, it considers only the boundaries (marked 'false' to consider) when solving only for boundary. And then push the primary operator. Then OpUnSetBc() is used to set the index to the  entities as it was intially.
</BLOCKQUOTE>

\subsubsection setIntegrationRules setIntegrationRules()
Afterward, Having the computation of LHS and RHS is defined in the setIntegrationRules. The instructions for the functions setIntegrationRules() is same as it was in SCL-1: Poisson's equation (homogeneous BC). 
\code
MoFEMErrorCode Poisson2DNonhomogeneous::setIntegrationRules() {
  MoFEMFunctionBegin;

  auto pipeline_mng = mField.getInterface<PipelineManager>();

  auto domain_rule_lhs = [](int, int, int p) -> int { return 2 * (p - 1); };
  auto domain_rule_rhs = [](int, int, int p) -> int { return 2 * (p - 1); };
  CHKERR pipeline_mng->setDomainLhsIntegrationRule(domain_rule_lhs);
  CHKERR pipeline_mng->setDomainRhsIntegrationRule(domain_rule_rhs);

  auto boundary_rule_lhs = [](int, int, int p) -> int { return 2 * p; };
  auto boundary_rule_rhs = [](int, int, int p) -> int { return 2 * p; };
  CHKERR pipeline_mng->setBoundaryLhsIntegrationRule(boundary_rule_lhs);
  CHKERR pipeline_mng->setBoundaryLhsIntegrationRule(boundary_rule_rhs);

  MoFEMFunctionReturn(0);
}
\endcode
\subsubsection solveSystem solveSystem()

For this problem , we devided our problem filed for domain and boundaries similar to Figure: 2
\anchor figure_poisson_nonhomogeneous_problem
\image html non-homogenous_poission_Matrix.png "Figure 1: Solving approch for U " width = 400px

At this stage we are not actually solve the system of equations directly using  KSP solver as we did din in SCL-1: Poisson's equation (homogeneous BC). But here we need to work on a a preconditioner to the solver called  FIELDSPLIT.Basically, it split the fields for seperately domain and boundary as a option - yes/no if needed. The part of the code is follows: 
\code
  // Setup fieldsplit (block) solver - optional: yes/no
  if (1) {
    PC pc;
    CHKERR KSPGetPC(ksp_solver, &pc);
    PetscBool is_pcfs = PETSC_FALSE;
    PetscObjectTypeCompare((PetscObject)pc, PCFIELDSPLIT, &is_pcfs);
 
    // Set up FIELDSPLIT, only when user set -pc_type fieldsplit
    // Identify the index for boundary entities, remaining will be for domain
    // Then split the fields for boundary and domain for solving
    if (is_pcfs == PETSC_TRUE) {
      IS is_domain, is_boundary;
      const MoFEM::Problem *problem_ptr;
      CHKERR DMMoFEMGetProblemPtr(dm, &problem_ptr);
      CHKERR mField.getInterface<ISManager>()->isCreateProblemFieldAndRank(
          problem_ptr->getName(), ROW, domainField, 0, 1, &is_boundary,
          &boundaryEntitiesForFieldsplit);
      CHKERR PCFieldSplitSetIS(pc, NULL, is_boundary);
      CHKERR ISDestroy(&is_boundary);
    }
  }
\endcode

The algorithm for the above code is to checks wheather the indices in the matrix need to be marked for domain or boundary. It set up the field-split solver using PETSc libraries for boundary entities(boundaryEntitiesForFieldsplit) and the remaining will be for domain. During the iteration 'IS' considers to solve the option for for domain and boundary so that the index sets are then used to configure the PCFIELDSPLIT solver to solve on the appropriate blockset of the problem. Finally, the code releases the memory associated with the boundary index set and goes for KSP to solve. And the greatest job to accumulate all these follows by VecGhostUpdateBegin, VecGhostUpdateEnd and DMoFEMMeshToLocalVector.

\code
 CHKERR KSPSetUp(ksp_solver);
 
  // Solve the system
  CHKERR KSPSolve(ksp_solver, F, D);
 
  // Scatter result data on the mesh
  CHKERR VecGhostUpdateBegin(D, INSERT_VALUES, SCATTER_FORWARD);
  CHKERR VecGhostUpdateEnd(D, INSERT_VALUES, SCATTER_FORWARD);
  CHKERR DMoFEMMeshToLocalVector(dm, D, INSERT_VALUES, SCATTER_REVERSE);
 
  MoFEMFunctionReturn(0);
}
\endcode

The rest of the code including outputResults() and main funtion does the same as \ref SCL-1: Poisson's equation (homogeneous BC).

Then, run the analysis, get the newly created output file, namely `out_result.h5m`. Convert it to `*.vtk` format. Then open it in Paraview and use the filter `WarpByScalar`, you will be able to see the deformation as below:

\section basic_tutorials_poisson_nonhomogeneous_result Results
\anchor figure_poisson_nonhomogeneous
\image html poisson_nonhomogeneous.png "Figure 2 : Poisson nonhomogeneous visualisation. Source term: 200sin(10x)cos(10y), boundary function: sin(10x)cos(10y)" width = 600px

\section basic_tutorials_poisson_nonhomogeneous_plain_program Plain program 


The plain program for both the implementation of the UDOs (\c *.hpp) and the
main program (\c *.cpp) are as follows

\subsection basic_tutorials_poisson_nonhomogeneous_impl_udo Implementation of User Data Operators (*.hpp)

\include poisson_2d_nonhomogeneous.hpp

\subsection basic_tutorials_poisson_nonhomogeneous_impl_main Implementation of the main program (*.cpp) 

\include poisson_2d_nonhomogeneous.cpp


*/
/*! \page basic_tutorials_poisson_homogeneous Poisson's equation (homogeneous boundary condition)

\tableofcontents

\note Prerequisite of this tutorial is \ref basic_tutorials_mesh_generation_2d
and \ref basic_tutorials_mesh_generation_3d (for the 3D extension
implementation) 

\section basic_tutorials_poisson_homogeneous_introduction Introduction

\subsection basic_tutorials_poisson_homogeneous_ilo Intended learning outcome

After this tutorial, you will learn:

- general structure of a program developed using MoFEM
- idea of Simple Interface in MoFEM and how to use it
- idea of Boundary element in MoFEM and how to use it
- process of creating User Data Operators (UDOs) and how to \b push them to the main program
- a way to handle homogeneous boundary condition in MoFEM
- utilisation of tools to read outputs (MOAB) and visualise them (Paraview)

\subsection basic_tutorials_poisson_homogeneous_the_problem The problem

In this first example, we will solve a simple Poisson' equation in 2D with
homogeneous boundary condition (zero boundary values) and non-zero body force 

\subsection basic_tutorials_poisson_homogeneous_discretisation Discretisation


\section basic_tutorials_poisson_homogeneous_implementation Implementation

The immediate question you may have regarding the implementation is how to
implement the matrices \b K and \b M as well as vectors \b f and \b g. This is
done through the implementation of the so-called User Data Operators
which is normally called Operators (for short) by MoFEM developers. As a common
practice, typically all the implementation of UDOs for a specific is put in a
<tt> *.hpp </tt> file. This file will be included in another <tt>*.cpp</tt> file
which contains all the neccessary classes and functions. Detailed explanation of
the implementation of UDOs and classes/functions are presented below

\subsection basic_tutorials_poisson_homogeneous_udo User Data Operators

As described in the previous, solving the Poisson problem with homogeneous would
require the computation and assembling of two matrices \b K and \b M and two
vectors \b f and \b g. These essential processes of computation and assembling
will be handled by four different UDOs which seperately deal with the four
matrices and vectors. They are

-# Poisson2DNonhomogeneousOperators::OpDomainLhs is responsible to calculate and
assemble the left-hand-side matrix \b K of domain element
-# Poisson2DNonhomogeneousOperators::OpDomainRhs is responsible to calculate and
assemble the right-hand-side vector \b f of domain element
-# Poisson2DNonhomogeneousOperators::OpBoundaryLhs is responsible to calculate
and assemble the left-hand-side matrix \b M of boundary element
-# Poisson2DNonhomogeneousOperators::OpBoundaryRhs is responsible to calculate
and assemble the right-hand-side vector \b g of boundary element

That was for the implementation of UDOs that are responsible for the calculation
and assembling of the matrices and vectors. Next part we will look at the
classes and functions and see how the developed UDOs are \b pushed to the main
program.

\subsection basic_tutorials_poisson_homogeneous_main_class The Poisson2DHomogeneous class


Also talk about the naming convention: camelBack and give reference to page for
naming convention in MoFEM.

\subsection basic_tutorials_poisson_homogeneous_the_main_function The main() function

Although, in the implementation, the \c main() function is located at the end of
the source code, we deliberately describe it here first in order to give you a
big picture and a linear thinking about the program.

Start with interface of PETSc, MOAB and MoFEM ...

It may be confusing at this moment ... general ideas is that this part create
the intefaces that allow MoFEM to talk to and utilise functionalities from PETSc
(solvers) and MOAB (element topology management). 

Now you can just focus on the part that actually run the analysis

\code
    // Run the main analysis
    Poisson2DHomogeneous poisson_problem(mb_instance, core);
    CHKERR poisson_problem.runAnalysis();
\endcode

\subsection basic_tutorials_poisson_homogeneous_the_class_functions The class functions

\subsubsection basic_tutorials_poisson_homogeneous_run_analysis Poisson2DHomogeneous::runAnalysis()

\subsubsection basic_tutorials_poisson_homogeneous_read_mesh Poisson2DHomogeneous::readMesh()

\subsubsection basic_tutorials_poisson_homogeneous_setup_problem Poisson2DHomogeneous::setupProblem()

\subsubsection basic_tutorials_poisson_homogeneous_set_integration_rules Poisson2DHomogeneous::setIntegrationRules()

\subsubsection basic_tutorials_poisson_homogeneous_boundary_condition Poisson2DHomogeneous::boundaryCondition()

\subsubsection basic_tutorials_poisson_homogeneous_assemble_system Poisson2DHomogeneous::assembleSystem()

\subsubsection basic_tutorials_poisson_homogeneous_solve_system Poisson2DHomogeneous::solveSystem()

\subsubsection basic_tutorials_poisson_homogeneous_output_results Poisson2DHomogeneous::outputResults()

\section basic_tutorials_poisson_homogeneous_results Results

\subsection basic_tutorials_poisson_homogeneous_run_the_program Run the program

\subsection basic_tutorials_poisson_homogeneous_output Output

\subsection basic_tutorials_poisson_homogeneous_discussion Discussion

\subsection basic_tutorials_poisson_homogeneous_possible_extension Possible extension

\section basic_tutorials_poisson_homogeneous_plain_program Plain program

The plain program for both the implementation of the UDOs (\c *.hpp) and the
main program (\c *.cpp) are as follows

\subsection Implementation of User Data Operators

\include poisson_2d_homogeneous.hpp

\subsection Implementation of the main program

\include poisson_2d_homogeneous.cpp



*/
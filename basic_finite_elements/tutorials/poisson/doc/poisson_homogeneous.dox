/*! \page basic_tutorials_poisson_homogeneous SCL-1: Poisson's equation (homogeneous BC)

\note Prerequisite of this tutorial include \ref basic_tutorials_mesh_generation_2d
and \ref basic_tutorials_mesh_generation_3d (for the 3D extension
implementation) 

<br>

\note After finishing this tutorial, if you would like to replicate the program
and practice yourself in an existing module or in your own module, you may wish
to have a look at \ref how_to_add_new_module_and_program and \ref
how_to_compile_program.

<br>

\note Intended learning outcome:
- general structure of a program developed using MoFEM
- idea of [Simple Interface](http://mofem.eng.gla.ac.uk/mofem/html/struct_mo_f_e_m_1_1_simple.html) in MoFEM and how to use it
- idea of Domain element in MoFEM and how to use it
- process of implementing User Data Operators (UDOs) to calculate and assemble
  stiffness matrix and force vector
- how to **push** UDOs to the *pipeline*
- a way to handle homogeneous boundary condition in MoFEM
- utilisation of tools to convert outputs (MOAB) and visualise them (Paraview)

\tableofcontents

\section basic_tutorials_poisson_homogeneous_introduction Introduction

\subsection basic_tutorials_poisson_homogeneous_problem The problem

In this first tutorial that actually solves something using MoFEM, we
will solve a simple Poisson's equation in 2D with homogeneous boundary condition
(zero boundary values). The physical example of this equation is that you
have a membrane that is fixed at its boundary and it experiences a uniformly
distributed force on its surface, then you are asked to estimate the
displacement of the membrane. The formal definition of the problem as follows 

Find \f$ u \in \bf{R} \f$ such that
\f[
\begin{aligned}
-\nabla \cdot \nabla u(\mathbf{x}) &= f \quad {\rm in} \quad {
\Omega} \\ u(\mathbf{x}) &= 0 \quad {\rm on} \quad \partial { \Omega}
\end{aligned}
\f]
where \f$ { \Omega} \f$ denotes the domain occupied by the body and
\f$ \partial { \Omega} \f$ is the boundary of the domain.
Additionally, \f$ f \f$ is the body force and \f$ {\bf x} \f$ is the position in
\f$ {x-y} \f$ space of a point in the domain.

Essentially, this is a continuous problem and there is analytical solution for
it. However, as a first practice with MoFEM, we are solving it numerically using
finite element approach. This is done by subdividing the domain into multiple
elements and solving a discrete problem.

As you may have already learned from the basic finite element method, in order
to approximate the field \f$ u \f$ of the problem equation, we need to 
derive the weak form. The procedure to achieve it is as follows

- First, multiplying both sides of the equation by a *test* function \f$ v \f$
  and then integrate over the domain \f$ \Omega \f$
\f[
-\int_\Omega v(\nabla \cdot \nabla u )= \int_\Omega v f 
\f]

- Second, apply the integration by parts on the left-hand side of the equation,
  we have
\f[
\int_\Omega \nabla v \cdot \nabla u - \int_{\partial \Omega} v {\bf n} \cdot \nabla u  = \int_\Omega v f 
\f]
It is noted that the test function \f$ v \f$ has to satisfy the homogeneous
  boundary condition, i.e. \f$ v=0 \f$ on \f$ \partial \Omega \f$. Substituting
  it to the above equation, we finally obtain the weak form of the problem
\f[
\int_\Omega \nabla v \cdot \nabla u = \int_\Omega v f 
\f]

We are now solving this equation of the weak form instead of the original
equation. This equation is asking for the solution of \f$ u \f$ that is true for
all test function \f$ v \f$. In order to achieve it, we will approximate \f$ u
\f$ following a process in finite element called *discretisation* which will be
presented in the next part.

\subsection basic_tutorials_poisson_homogeneous_discretisation Discretisation

As mentioned above, instead of trying to solve the problem analytically, we will
approximate \f$ u \f$ assuming its solution has the form
\f[
u \approx u^h = \sum_{j=0}^{N-1} \phi_j U_j
\f]
This expression can be interpreted as follow. Find the approximate solution \f$
u^h \f$ of \f$ u \f$ where \f$ u^h \f$ is calculated by the summation of the
multiplication of the *approximation functions* \f$ \phi_j \f$ and
*coefficients* \f$ U_j \f$. 

Sometimes, \f$ \phi_j \f$ is also called shape functions and \f$ U_j \f$ called *degrees of freedom* of the problem. In the implementation process
which will be discussed later in this tutorial, MoFEM gives you values of \f$
u^h \f$ by default (provided that you give it some hints) and you will find the
solution of \f$ u^h \f$, of course, with the help of MoFEM.

Remember that, in the weak form, we have another term that also needs to be
taken care of, that is the test function \f$ v \f$. As we were saying, the weak
form has to be satisfied with all test function \f$ v \f$ meaning it has to be
true with the arbitrary choice of \f$ v_i=\phi_i \f$.

Substituting \f$ u \f$ and \f$ v \f$ into the weak form, we have the discrete
form of the problem is given by 
\f[
\int_{\Omega^e} \nabla \phi_i \cdot \nabla \left( \sum_j U_j \phi_j \right) = \int_{\Omega^e} \phi_i f
\f]
Moving \f$ U_j \f$ outside of the parentheses and rearraging the equation, we
have 
\f[
\sum_j \left( \int_{\Omega^e} \nabla \phi_i \cdot \nabla \phi_j \right) U_j   = \int_{\Omega^e} \phi_i f
\f]

Now, the problem becomes: finding the vector of coefficients \f$ {\bf U} \f$
such that 
\f[
{\bf KU} = {\bf F}  
\f]
where \f$ {\bf K} \f$ and \f$ {\bf F} \f$ are the global stiffness matrix (left
hand side) and global force vector (right hand side) calculated over the whole
domain, respectively. \f$ {\bf K} \f$ and \f$ {\bf F} \f$ are obtained by
assembling from all elements (entity) in the domain, and the components
of element stiffness matrix and element force vector are calculated as
\f[
  \begin{align}
    K_{ij}^e &= \int_{\Omega^e} \nabla \phi_i \cdot \nabla  \phi_j, \\
    F_i^e &= \int_{\Omega^e} \phi_i f
  \end{align}
\f]

We almost place where we can start the implementation, but still, you may ask
how computers can handle the integral terms. Of course, we will not ask
computers to calculate the integrals directly in an infinite sense, instead it
is done using *quadrature* which is in a finite sense and commonly used in
finite element method. In order word, the integrals are approximated by the sum
of a set of points on each element along with their weights as follows
\f[
  \begin{align}
    K_{ij}^e &= \int_{\Omega^e} \nabla \phi_i \cdot \nabla \phi_j \approx \sum_q \nabla \phi_i \left( {\bf x}_q \right) \cdot \nabla \phi_j \left( {\bf x}_q \right) w_q, \\ 
    F_i^e &= \int_{\Omega^e} \phi_i f \approx \sum_q \phi_i \left( {\bf x}_q \right) f \left( {\bf x}_q \right) w_q
  \end{align}
\f]
where \f$ {\bf x}_q \f$ and \f$ w_q \f$ are location and weight of the
quadrature point. These equations can be interpreted as follows

The approximated value of the component at row \f$ i \f$ and column \f$ j \f$ of
the element stiffness matrix \f$ K \f$ of element \f$ e \f$ is calculated by
taking the summation over all quadrature points of the multiplication of 
- the first derivative of the \f$ i^{\rm th} \f$ approximation function \f$ \phi
  \f$ evaluated at quadrature point \f$ q \f$, 
- the first derivative of the \f$ j^{\rm th} \f$ approximation function \f$ \phi
  \f$ evaluated at the same quadrature point \f$ q \f$, and 
- the weight of that quadrature point \f$ q \f$.

Likewise, the approximated value of the component at row \f$ i \f$ of the
element force vector \f$ F \f$ of element \f$ e \f$ is calculated by taking the
summation over all quadrature points of the multiplication of
- the \f$ i^{\rm th} \f$ approximation function \f$ \phi \f$ evaluated at
  quadrature point \f$ q \f$,
- the body force evaluated at the same quadrature point \f$ q \f$, and
- the weight of that quadrature point \f$ q \f$.

More details on this matter can be found here \ref lesson1.

To this end, we have established a linear system of the primary variable \f$
{\bf U} \f$ through \f$ {\bf K} \f$ and \f$ {\bf F} \f$. In MoFEM, we will use
an iterative solver
([KSP](https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/index.html))
to solve for \f$ {\bf U} \f$ and apply steps to postprocess the solution and
visualise it.




\section basic_tutorials_poisson_homogeneous_implementation Implementation 

The immediate question you may have regarding the implementation is how to
implement the matrix **K** and vector **f**. This is
done through the implementation of the so-called **User Data Operators**. UDOs
are the essential part of MoFEM and they are present in all finite element
problems implemented using MoFEM. UDO is normally called Operator (for short) by MoFEM developers.

As a common practice, typically all the implementation of UDOs for a specific
problem is put in a `*.hpp` file. This file will be included in the main `*.cpp`
file which contains all the necessary classes and functions. Detailed
explanation of the implementation of UDOs as well as classes/functions is
presented below

\subsection basic_tutorials_poisson_homogeneous_udo User Data Operators 

As described in the previous, solving the Poisson problem with homogeneous would
require the computation and assembling of the matrix **K** and
vector **f**. These essential processes of computation and assembling
will be handled by four different UDOs which separately deal with the four
matrices and vectors. They are

1. Poisson2DHomogeneousOperators::OpDomainLhs is responsible to calculate and
   assemble the left-hand-side matrix **K** of domain element  
2. Poisson2DHomogeneousOperators::OpDomainRhs is responsible to calculate and
   assemble the right-hand-side vector **f** of domain element 

That was for the implementation of UDOs that are responsible for the calculation
and assembling of the matrices and vectors. Next part we will look at the
class and functions and see how the implemented UDOs are **pushed** to the main
program.

Having the matrix K and vector f implemented, you now may ask the question of
how to feed it the main program. This is done through the process called *push
operator* that you will find out in more details in later in this tutorials,
\ref basic_tutorials_poisson_homogeneous_assemble

\subsection basic_tutorials_poisson_homogeneous_class The Poisson2DHomogeneous class

This part is about the class Poisson2DHomogeneous

Also talk about the naming convention: camelBack and give reference to page for
naming convention in MoFEM.


\subsubsection basic_tutorials_poisson_homogeneous_constructor Poisson2DHomogeneous()

This part is about the constructor Poisson2DHomogeneous::Poisson2DHomogeneous()


  
\subsubsection basic_tutorials_poisson_homogeneous_readmesh readMesh()

This part is about the function Poisson2DHomogeneous::readMesh()

This is the first member function
  

\subsubsection basic_tutorials_poisson_homogeneous_setupproblem setupProblem()

This part is about the function Poisson2DHomogeneous::setupProblem()

The next member function deals with the setting up of the problem

\subsubsection basic_tutorials_poisson_homogeneous_intergration setIntegrationRules() 

This part is about the function Poisson2DHomogeneous::setIntegrationRules()

\subsubsection basic_tutorials_poisson_homogeneous_bc boundaryCondition() 

This part is about the function Poisson2DHomogeneous::boundaryCondition()

\subsubsection basic_tutorials_poisson_homogeneous_assemble assembleSystem() 

This part is about the function Poisson2DHomogeneous::assembleSystem()

\subsubsection basic_tutorials_poisson_homogeneous_solve solveSystem() 

This part is about the function Poisson2DHomogeneous::solveSystem()

\subsubsection basic_tutorials_poisson_homogeneous_output outputResults() 

This part is about the function Poisson2DHomogeneous::outputResults()

\subsubsection basic_tutorials_poisson_homogeneous_run_analysis runAnalysis() 

This part is about the function Poisson2DHomogeneous::runAnalysis()

\subsection basic_tutorials_poisson_homogeneous_main The main() function

Although, in the implementation, the `main` function is located at the end of
the source code, we deliberately describe it here first in order to give you a
big picture and a linear thinking about the program.

Start with interface of PETSc, MOAB and MoFEM ...

It may be confusing at this moment ... general ideas is that this part create
the intefaces that allow MoFEM to talk to and utilise functionalities from PETSc
(solvers) and MOAB (element topology management). 

Now you can just focus on the part that actually run the analysis

\code
    // Run the main analysis
    Poisson2DHomogeneous poisson_problem(mb_instance, core);
    CHKERR poisson_problem.runAnalysis();
\endcode


\section basic_tutorials_poisson_homogeneous_result Results

Body force is set to be \f$ f=5.0 \f$ 

\subsection basic_tutorials_poisson_homogeneous_run_program Run the program

\subsection basic_tutorials_poisson_homogeneous_op Output



Visualisation in Paraview

\anchor figure_poisson_homogeneous
\image html poisson_homogeneous.png "Figure 1: Poisson homogeneous visualisation." width = 900px


\subsection basic_tutorials_poisson_homogeneous_discussion Discussion

\subsection basic_tutorials_poisson_homogeneous_extension Possible extension



\section basic_tutorials_poisson_homogeneous_plain_program Plain program 


The plain program for both the implementation of the UDOs (\c *.hpp) and the
main program (\c *.cpp) are as follows

\subsection basic_tutorials_poisson_homogeneous_impl_udo Implementation of User Data Operators (*.hpp)

\include poisson_2d_homogeneous.hpp

\subsection basic_tutorials_poisson_homogeneous_impl_main Implementation of the main program (*.cpp) 

\include poisson_2d_homogeneous.cpp




*/
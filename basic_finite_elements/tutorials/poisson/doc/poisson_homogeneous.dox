/*! \page basic_tutorials_poisson_homogeneous SCL-1: Poisson's equation (homogeneous BC)

\note Prerequisite of this tutorial include \ref basic_tutorials_mesh_generation_2d
and \ref basic_tutorials_mesh_generation_3d (for the 3D extension
implementation) 

<br>

\note Intended learning outcome:
- general structure of a program developed using MoFEM
- idea of [Simple Interface](http://mofem.eng.gla.ac.uk/mofem/html/struct_mo_f_e_m_1_1_simple.html) in MoFEM and how to use it
- idea of Domain element in MoFEM and how to use it
- process of implementing User Data Operators (UDOs) to calculate and assemble
  stiffness matrix and force vector
- how to **push** UDOs to the *pipeline*
- a way to handle homogeneous boundary condition in MoFEM
- utilisation of tools to convert outputs (MOAB) and visualise them (Paraview)

<br>

\note After finishing this tutorial, if you would like to replicate the program
and practice yourself in an existing module or in your own module, you may wish
to have a look at \ref how_to_add_new_module_and_program and \ref
how_to_compile_program.

\tableofcontents

\section basic_tutorials_poisson_homogeneous_introduction Introduction

\subsection basic_tutorials_poisson_homogeneous_problem The problem

In this first tutorial that actually solves something using MoFEM, we
will solve a simple Poisson's equation in 2D with homogeneous boundary condition
(zero boundary values). The physical example of this equation is that you
have a membrane that is fixed at its boundary and it experiences a uniformly
distributed force on its surface, then you are asked to estimate the
displacement of the membrane. The formal definition of the problem as follows 

Find \f$ u \in \bf{R} \f$ such that
\f[
\begin{aligned}
-\nabla \cdot \nabla u(\mathbf{x}) &= f \quad {\rm in} \quad {
\Omega} \\ u(\mathbf{x}) &= 0 \quad {\rm on} \quad \partial { \Omega}
\end{aligned}
\f]
where \f$ { \Omega} \f$ denotes the domain occupied by the body and
\f$ \partial { \Omega} \f$ is the boundary of the domain.
Additionally, \f$ f \f$ is the body force and \f$ {\bf x} \f$ is the position in
\f$ {x-y} \f$ space of a point in the domain.

Essentially, this is a continuous problem and there is analytical solution for
it. However, as a first practice with MoFEM, we are solving it numerically using
finite element approach. This is done by subdividing the domain into multiple
elements and solving a discrete problem.

As you may have already learned from the basic finite element method, in order
to approximate the field \f$ u \f$ of the problem equation, we need to 
derive the weak form. The procedure to achieve it is as follows

- First, multiplying both sides of the equation by a *test* function \f$ v \f$
  and then integrate over the domain \f$ \Omega \f$
\f[
-\int_\Omega v(\nabla \cdot \nabla u )= \int_\Omega v f 
\f]

- Second, apply the integration by parts on the left-hand side of the equation,
  we have
\f[
\int_\Omega \nabla v \cdot \nabla u - \int_{\partial \Omega} v {\bf n} \cdot \nabla u  = \int_\Omega v f 
\f]
It is noted that the test function \f$ v \f$ has to satisfy the homogeneous
  boundary condition, i.e. \f$ v=0 \f$ on \f$ \partial \Omega \f$. Substituting
  it to the above equation, we finally obtain the weak form of the problem
\f[
\int_\Omega \nabla v \cdot \nabla u = \int_\Omega v f 
\f]

We are now solving this equation of the weak form instead of the original
equation. This equation is asking for the solution of \f$ u \f$ that is true for
all test function \f$ v \f$. In order to achieve it, we will approximate \f$ u
\f$ following a process in finite element called *discretisation* which will be
presented in the next part.

\subsection basic_tutorials_poisson_homogeneous_discretisation Discretisation

As mentioned above, instead of trying to solve the problem analytically, we will
approximate \f$ u \f$ assuming its solution has the form
\f[
u \approx u^h = \sum_{j=0}^{N-1} \phi_j U_j
\f]
This expression can be interpreted as follow. Find the approximate solution \f$
u^h \f$ of \f$ u \f$ where \f$ u^h \f$ is calculated by the summation of the
multiplication of the *approximation functions* \f$ \phi_j \f$ and
*coefficients* \f$ U_j \f$. 

Sometimes, \f$ \phi_j \f$ is also called shape functions and \f$ U_j \f$ called *degrees of freedom* of the problem. In the implementation process
which will be discussed later in this tutorial, MoFEM gives you values of \f$
u^h \f$ by default (provided that you give it some hints) and you will find the
solution of \f$ u^h \f$, of course, with the help of MoFEM.

Remember that, in the weak form, we have another term that also needs to be
taken care of, that is the test function \f$ v \f$. As we were saying, the weak
form has to be satisfied with all test function \f$ v \f$ meaning it has to be
true with the arbitrary choice of \f$ v_i=\phi_i \f$.

Substituting \f$ u \f$ and \f$ v \f$ into the weak form, we have the discrete
form of the problem is given by 
\f[
\int_{\Omega^e} \nabla \phi_i \cdot \nabla \left( \sum_j U_j \phi_j \right) = \int_{\Omega^e} \phi_i f
\f]
Moving \f$ U_j \f$ outside of the parentheses and rearraging the equation, we
have 
\f[
\sum_j \left( \int_{\Omega^e} \nabla \phi_i \cdot \nabla \phi_j \right) U_j   = \int_{\Omega^e} \phi_i f
\f]

Now, the problem becomes: finding the vector of coefficients \f$ {\bf U} \f$
such that 
\f[
{\bf KU} = {\bf F}  
\f]
where \f$ {\bf K} \f$ and \f$ {\bf F} \f$ are the global stiffness matrix (left
hand side) and global force vector (right hand side) calculated over the whole
domain, respectively. \f$ {\bf K} \f$ and \f$ {\bf F} \f$ are obtained by
assembling from all elements (entity) in the domain, and the components
of element stiffness matrix and element force vector are calculated as
\f[
  \begin{align}
    K_{ij}^e &= \int_{\Omega^e} \nabla \phi_i \cdot \nabla  \phi_j, \\
    F_i^e &= \int_{\Omega^e} \phi_i f
  \end{align}
\f]
One thing we can notice here is that the matrix \f$ {\bf K} \f$ is symmetric
  which means later in the implementation we can save computer memory by
  assembling and storing data of just a half of the matrix.


We are almost at the place where we can start the implementation, but still, you
may ask how computers can handle the integral terms. Of course, we will not ask
computers to calculate the integrals directly in an infinite sense, instead it
is done using *quadrature* which is in a finite sense and commonly used in
finite element method. In order word, the integrals are approximated by the sum
of a set of points on each element along with their weights as follows
\f[
  \begin{align}
K_{ij}^e &= \int_{\Omega^e} \nabla \phi_i \cdot \nabla \phi_j \approx \sum_q
\nabla \phi_i \left( {\bf x}_q \right) \cdot \nabla \phi_j \left( {\bf x}_q
\right) w_q \label{eqn_stiffness}, \\ 
    F_i^e &= \int_{\Omega^e} \phi_i f \approx \sum_q \phi_i \left( {\bf x}_q \right) f \left( {\bf x}_q \right) w_q
  \end{align}
\f]
where \f$ {\bf x}_q \f$ and \f$ w_q \f$ are location and weight of the
quadrature point. These equations can be interpreted as follows

The approximated value of the component at row \f$ i \f$ and column \f$ j \f$ of
the element stiffness matrix \f$ K \f$ of element \f$ e \f$ is calculated by
taking the summation over all quadrature points of the multiplication of 
- the first derivative of the \f$ i^{\rm th} \f$ approximation function \f$ \phi
  \f$ evaluated at quadrature point \f$ q \f$, 
- the first derivative of the \f$ j^{\rm th} \f$ approximation function \f$ \phi
  \f$ evaluated at the same quadrature point \f$ q \f$, and 
- the weight of that quadrature point \f$ q \f$.

Likewise, the approximated value of the component at row \f$ i \f$ of the
element force vector \f$ F \f$ of element \f$ e \f$ is calculated by taking the
summation over all quadrature points of the multiplication of
- the \f$ i^{\rm th} \f$ approximation function \f$ \phi \f$ evaluated at
  quadrature point \f$ q \f$,
- the body force evaluated at the same quadrature point \f$ q \f$, and
- the weight of that quadrature point \f$ q \f$.

More details on this matter can be found here \ref lesson1.

To this end, we have established a linear system of the primary variable \f$
{\bf U} \f$ through \f$ {\bf K} \f$ and \f$ {\bf F} \f$. In MoFEM, we will use
an iterative solver
([KSP](https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/index.html))
to solve for \f$ {\bf U} \f$ and apply steps to postprocess the solution and
visualise it.


\section basic_tutorials_poisson_homogeneous_implementation Implementation 

An immediate question you may have regarding the implementation is how to
implement the matrix \f$ {\bf K} \f$ and vector \f$ {\bf F} \f$. This is
done through the implementation of the so-called **User Data Operators**. UDOs
are the essential part of MoFEM and they are present in all finite element
problems implemented in MoFEM. UDO is normally called Operator (for short) by
MoFEM developers. Once UDOs are implemented, they will be *pushed* to the working **pipeline**.

Here we have introduced _two important concepts_ in MoFEM
- **UDOs** are responsible for calculation of certain things, e.g. stiffness
  matrix, force vector, inverse of Jacobian, field values, field gradients, etc., and 
- **Pipeline** is where you *pushed* UDOs to in a certain order, e.g. UDOs for
  calculating field values and field gradients (nonlinear problem) are pushed
  before UDOs calculating stiffness matrix and force vector. After being pushed
  to the Pipeline, those UDOs will be executed sequentially.

As a common practice, typically all the implementation of UDOs for a specific
problem is put in a `*.hpp` file. This file will be included in the main `*.cpp`
file which contains all the necessary classes and functions. Detailed
explanation of the implementation of UDOs, how you pushed UDOs to Pipeline as
well as developement of classes/functions are presented below

\subsection basic_tutorials_poisson_homogeneous_udo User Data Operators 

As described in the previous, solving the Poisson problem with homogeneous would
require the computation and assembling of the matrix \f$ {\bf K} \f$ and
vector \f$ {\bf F} \f$. These essential processes of computation and assembling
will be handled by two different UDOs which separately deal with the matrix and
vector. They are

1. Poisson2DHomogeneousOperators::OpDomainLhsMatrixK is responsible for the
   calculation and assemble of the left-hand-side matrix \f$ {\bf K} \f$
   
2. Poisson2DHomogeneousOperators::OpDomainRhsVectorF is responsible for the
   calculation and assemble of the right-hand-side vector \f$ {\bf F} \f$

Before going into details of the implementation of the two UDOs in
poisson_2d_homogeneous.hpp, let's have a look at the first few lines of code of
the file that includes some libaries for finite element implementation, some
aliases, and declaration/initialisation as commented below.

\code
// Define name if it has not been defined yet
#ifndef __POISSON2DHOMOGENEOUS_HPP__
#define __POISSON2DHOMOGENEOUS_HPP__

// Include standard library and Header file for basic finite elements
// implementation
#include <stdlib.h>
#include <BasicFiniteElements.hpp>

// Use of alias for some specific functions
// We are solving Poisson's equation in 2D so Face element is used
using FaceEle = MoFEM::FaceElementForcesAndSourcesCore;
using OpFaceEle = MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator;
using EntData = DataForcesAndSourcesCore::EntData;

// Namespace that contains necessary UDOs, will be included in the main program
namespace Poisson2DHomogeneousOperators {

// Declare FTensor index for 2D problem
FTensor::Index<'i', 2> i;

// For simplicity, source term f will be constant throughout the domain
const double body_source = 5.;


// Implementation of the UDOs below this point

}

\endcode


Now, we will look in details how the two main operators
Poisson2DHomogeneousOperators::OpDomainLhsMatrixK and
Poisson2DHomogeneousOperators::OpDomainRhsVectorF are implemented.


\subsubsection OpDomainLhsMatrixK
The first UDO
Poisson2DHomogeneousOperators::OpDomainLhsMatrixK is responsible for the
calculation and assemble of the left-hand-side matrix \f$ {\bf K} \f$

First, let's look at the structure of the UDO to calculate matrix \f$
{\bf K} \f$, also the general structure of all of the UDO implemented in MoFEM

\code 
struct OpDomainLhsMatrixK : public OpFaceEle {
public:
  OpDomainLhsMatrixK(std::string row_field_name, std::string col_field_name)
      : OpFaceEle(row_field_name, col_field_name, OpFaceEle::OPROWCOL) {
    sYmm = true;
  }

  MoFEMErrorCode doWork(int row_side, int col_side, EntityType row_type,
                        EntityType col_type, EntData &row_data,
                        EntData &col_data) {
  
  // Implementation of doWork() below this point

  }

private:
  MatrixDouble locLhs, transLocLhs;
};
\endcode

We have the class `OpDomainLhsMatrixK` that is inherited from `OpFaceEle` which
is the alias of the base class
MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator.
This newly created class has two public objects `OpDomainLhsMatrixK()` and
`doWork()` which can be accessed from outside of the class, and two private
objects `locLhs` and `transLocLhs` of type `MatrixDouble` which can be accessed
only from inside of the class for calculation and assemble of local stiffness
matrix. This follows the concept of [data
encapsulation](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))
to hide values and objects inside the class as much as possible. We will discuss
a little more details of those four objects of the class in the followings

- `OpDomainLhsMatrixK()`
\code 
  OpDomainLhsMatrixK(std::string row_field_name, std::string col_field_name)
      : OpFaceEle(row_field_name, col_field_name, OpFaceEle::OPROWCOL) {
    sYmm = true;
  }
\endcode
  This public member function has two input arguments which are the
  row_field_name and col_field_name carrying the names of the field for row and
  column, respectively. In general, these two field names can be different. In
  this particular case of Poisson's problem with homogeneous boundary condition,
  we will see later, they take the same field name of "U" for both row and
  column. OpFaceEle::OPROWCOL because we assemble stiffness matrix that has data
  on both row and column. The boolean `sYmm = true` is set since we know matrix
  \f$ K \f$ is symmetric and we can just assembling and storing data of half of the matrix.

- `doWork()`
\code
  MoFEMErrorCode doWork(int row_side, int col_side, EntityType row_type,
                        EntityType col_type, EntData &row_data,
                        EntData &col_data) {
  
  // Implementation of doWork() below this point

  }
\endcode
  This public member function is the core part of the UDO implementation. It
  decides how to calculate the local matrix components and how to assemble them
  to the global matrix. All of the mathematical derivations that we did in the
  previous section of this tutorial will be implemented in this function. More
  discussion on this essential function will be given right below.

- `locLhs` <br>
  This private member object of type MatrixDouble is used to
  store the results of the calculation of components of element stiffness
  matrix. This object is used only in function `doWork()` above which is a
  member of the current class. That is why it is declared as a private object
  meaning it can be accessed only inside of the class.
  
- `transLocLhs` <br>
  This private member object also of type MatrixDouble is
  used to assemble the transpose of `locLhs`. This object is used only in
  function `doWork()` so it is also declared as a private object of the class `OpDomainLhsMatrixK`.

Now we take a closer look on the details of the implementation of the member
function `doWork()` which is the most essential part of the UDO implementation.
Full codes for this function as follows
\code 
  MoFEMErrorCode doWork(int row_side, int col_side, EntityType row_type,
                        EntityType col_type, EntData &row_data,
                        EntData &col_data) {
    MoFEMFunctionBegin;

    const int nb_row_dofs = row_data.getIndices().size();
    const int nb_col_dofs = col_data.getIndices().size();

    if (nb_row_dofs && nb_col_dofs) {

      locLhs.resize(nb_row_dofs, nb_col_dofs, false);
      locLhs.clear();

      // get element area
      const double area = getMeasure();

      // get number of integration points
      const int nb_integration_points = getGaussPts().size2();
      // get integration weights
      auto t_w = getFTensor0IntegrationWeight();

      // get derivatives of base functions on row
      auto t_row_diff_base = row_data.getFTensor1DiffN<2>();

      // START THE LOOP OVER INTEGRATION POINTS TO CALCULATE LOCAL MATRIX
      for (int gg = 0; gg != nb_integration_points; gg++) {
        const double a = t_w * area;

        for (int rr = 0; rr != nb_row_dofs; ++rr) {
          // get derivatives of base functions on column
          auto t_col_diff_base = col_data.getFTensor1DiffN<2>(gg, 0);

          for (int cc = 0; cc != nb_col_dofs; cc++) {
            locLhs(rr, cc) += t_row_diff_base(i) * t_col_diff_base(i) * a;

            // move to the derivatives of the next base functions on column
            ++t_col_diff_base;
          }

          // move to the derivatives of the next base functions on row
          ++t_row_diff_base;
        }

        // move to the weight of the next integration point
        ++t_w;
      }

      // FILL VALUES OF LOCAL MATRIX ENTRIES TO THE GLOBAL MATRIX
      CHKERR MatSetValues(getKSPB(), row_data, col_data, &locLhs(0, 0),
                          ADD_VALUES);
      if (row_side != col_side || row_type != col_type) {
        transLocLhs.resize(nb_col_dofs, nb_row_dofs, false);
        noalias(transLocLhs) = trans(locLhs);
        CHKERR MatSetValues(getKSPB(), col_data, row_data, &transLocLhs(0, 0),
                            ADD_VALUES);
      }
    }

    MoFEMFunctionReturn(0);
  }
\endcode

First, let's talk about the structure of this function, 
\code 
  MoFEMErrorCode doWork(int row_side, int col_side, EntityType row_type,
                        EntityType col_type, EntData &row_data,
                        EntData &col_data) {
    MoFEMFunctionBegin;

    // Core implementation goes here

    MoFEMFunctionReturn(0);
  }
\endcode

You will first notice that all functions written in MoFEM will include error
handling as we can see here with keywords: `MoFEMErrorCode`,
`MoFEMFunctionBegin;`, and `MoFEMFunctionReturn(0);`

Regarding arguments of this `doWork()` function, it has six arguments and all of
them are input arguments. The values of these input arguments are provided by
MoFEM based on the type of the elements we are solving (edge, face, volume). In
this particular case, as we solve 2D Poisson problem using triangular mesh, we
use MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator (alias
`OpFaceEle`) as seen previously at the first lines of code for the struct
`OpDomainLhsMatrixK`. And the data structure of the entities (elements) are
provided accordingly thanks to DataForcesAndSourcesCore::EntData (alias
`EntData`).

The arguments are divided in three groups
- `row_side` and `col_side` takes integer values of {0, 1, 2}
- `row_type` and `col_type` takes value of {MBVERTEX, MBEDGE, MBTRI} (see more [Hierarchical basis
  functions](http://mofem.eng.gla.ac.uk/mofem/html/hierarchical_approximation_1.html))
- `&row_data` and `&col_data` are two important pointers that have information
  of the DOFs, and basis function values, field values, field gradients at
  integration (Gauss) points.

Moving into the main implementation of `doWork()` function, we will see
information about the number of DOFs on row and column are extracted from the
database
\code
const int nb_row_dofs = row_data.getIndices().size();
const int nb_col_dofs = col_data.getIndices().size();
\endcode

Then there is an `if statement` to make sure that data for row and column are
both valid.
\code
if (nb_row_dofs && nb_col_dofs) {

  // Main implementation goes here

}
\endcode

Once the program is confident that the data for row and column are all valid,
it starts to initialise the local stiffness (LHS) matrix whose components will
be calculated and assembled to the global matrix.
\code
locLhs.resize(nb_row_dofs, nb_col_dofs, false);
locLhs.clear();
\endcode

Then you will get the area which is needed later when you integrate the function
to calculate the stiffness matrix.
\code
// get element area
const double area = getMeasure();
\endcode
It is worth noting that `getMeasure()` is a generic function and the value you
get depends on which entity type you are working with. For example, in this UDO,
you are working with face entities (triangles), `getMeasure()` gives you face
area. If you are dealing with edge (for boundary element) or volume entities
(for volume domain), you would get edge length or element volume, respectively.

Next, as required for the calculation of stiffness matrix in Eq. (3), we need
the number of integration points (\f$ q \f$) and their weights ((\f$ w_q \f$)) which can be done as follows
\code
// get number of integration points
const int nb_integration_points = getGaussPts().size2();
// get integration weights
auto t_w = getFTensor0IntegrationWeight();
\endcode
Here `getFTensor0IntegrationWeight()` is a function of
MoFEM::ForcesAndSourcesCore::UserDataOperator and it returns a zeroth-order
FTensor object ([Tensor template
library](http://mofem.eng.gla.ac.uk/mofem/html/group__ftensor.html)) that stores
value of integration weight. We prefer to use FTensor anywhere we can because it
is compact and highly efficient. In MoFEM implementation, FTensor object is
normally named with the prefix `t_`.

Once the number of Gauss points and their weights are determined, the remaining
component to calculate stiffness matrix would include the gradients of the basis
function evaluated at the integration (Gauss) point, \f$ \nabla \phi_i, \nabla
\phi_j \f$ ,for row and column, respectively, and the loop over all the Gauss
points. They are done in the following part of the code
\code
      // get derivatives of base functions on row
      auto t_row_diff_base = row_data.getFTensor1DiffN<2>();

      // START THE LOOP OVER INTEGRATION POINTS TO CALCULATE LOCAL MATRIX
      for (int gg = 0; gg != nb_integration_points; gg++) {
        const double a = t_w * area;

        for (int rr = 0; rr != nb_row_dofs; ++rr) {
          // get derivatives of base functions on column
          auto t_col_diff_base = col_data.getFTensor1DiffN<2>(gg, 0);

          for (int cc = 0; cc != nb_col_dofs; cc++) {
            locLhs(rr, cc) += t_row_diff_base(i) * t_col_diff_base(i) * a;

            // move to the derivatives of the next base functions on column
            ++t_col_diff_base;
          }

          // move to the derivatives of the next base functions on row
          ++t_row_diff_base;
        }

        // move to the weight of the next integration point
        ++t_w;
      }
\endcode
Here you can see inside the loop over the integration points, we have two other
nested loops that loop over the row (\f$i\f$) and column (\f$j\f$) DOFs of the matrix which ultimately calculated similar to the way
they are presented in Eq. (3)
\code
locLhs(rr, cc) += t_row_diff_base(i) * t_col_diff_base(i) * a;
\endcode
where `a` is the intemediate variable of type `double` and calculated earlier as
\code
const double a = t_w * area;
\endcode
where `area` can be considered as the determinant of the Jacobian of the
transformation from the physical (global) coordinate system to the reference
(local) coordinate system. See more about the integration and Jacobian at \ref
lesson1.

It should be noticed that at the end of each loop over the row and column
DOFs, `t_row_diff_base` and `t_col_diff_base` which have the values of the
gradients of the basis function are moved/shifted to the next chunk of the
memory which stores values of another set of gradients of basis function
associated with DOFs. The same technique is applied to move `t_w` to the weight
of the next Gauss point in the memory.

\b Note: You might have also recognised that in the traditional finite element
implementation, you will probably have, at the same place of the code, the
structure of the main nested loop like this

- Loop over all elements
  - Loop over all integration points
    - Calculation of the local stiffness matrix components and fill them to the
      global matrix

However, finite element implementation in MoFEM is slightly different as you may
have already noticed. MoFEM still have the nested loops; however, in the
implementation of UDO, you have only one loop over the integration points
inside which you calculate the local stiffness matrix components and assemble
them to the global matrix. The loop over the elements (or `entities` in the
context of [Hierarchical basis
functions](http://mofem.eng.gla.ac.uk/mofem/html/hierarchical_approximation_1.html)
used in MoFEM) is done in the main program, outside of the UDO. Details of how
this loop is triggered is presented in \ref
basic_tutorials_poisson_homogeneous_solve.

That was the description for the part of the code responsible for the
calculation of the components of the element stiffness matrix. Now we will talk
about the last part of the current UDO which is about the assembling/filling
from local (element) stiffness matrix to global stiffness matrix handled by
PETSc thay is done by the following lines of code
\code
      // FILL VALUES OF LOCAL MATRIX ENTRIES TO THE GLOBAL MATRIX
      CHKERR MatSetValues(getKSPB(), row_data, col_data, &locLhs(0, 0),
                          ADD_VALUES);
\endcode
This process of assembling matrix is done using the function `MatSetValues()`
which set the values for the global matrix and later will be solved using PETSc.
This function requires the inputs of `getKSPB()`, `row_data`, `col_data`, the
memory address where the first components of the local stiffness matrix
`&locLhs(0, 0)` is stored, and a flag to add value `ADD_VALUES`. Here
`getKSPB()` is the method to set the value of LHS matrix that will be solved by
the iterative solver namely [KSP](https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/index.html) in PETSc.

And finally, as global \f$ {\bf K} \f$ matrix is also symmetric, we tranpose
everything that has already assembled to form the full matrix of \f$ {\bf K} \f$
\code
      if (row_side != col_side || row_type != col_type) {
        transLocLhs.resize(nb_col_dofs, nb_row_dofs, false);
        noalias(transLocLhs) = trans(locLhs);
        CHKERR MatSetValues(getKSPB(), col_data, row_data, &transLocLhs(0, 0),
                            ADD_VALUES);
      }
\endcode

\subsubsection OpDomainRhsVectorF
In this part, we will talk about the implementation of the second UDO
Poisson2DHomogeneousOperators::OpDomainRhsVectorF which is responsible for the
calculation and assemble of the right-hand-side force vector \f$ {\bf F} \f$

Similar to what implemented for the \f$ {\bf K} \f$ matrix we discussed above,
the implementation of the UDO for the \f$ {\bf F} \f$ vector has very similar
structure with slightly different functions
\code
struct OpDomainRhsVectorF : public OpFaceEle {
public:
  OpDomainRhsVectorF(std::string field_name)
      : OpFaceEle(field_name, OpFaceEle::OPROW) {}

  MoFEMErrorCode doWork(int side, EntityType type, EntData &data) {

  // Implementation of doWork() below this point

  }

private:
  VectorDouble locRhs;
};
\endcode
We have the public objects of `OpDomainRhsVectorF()` and `doWork()` and private
object of `locRhs`. Here the name of the main function is changed to
`OpDomainRhsVectorF` to reflect what it does. Additionally, as we are
calculating and assembling vector instead of matrix, we need only one input of
`field_name` and we tell MoFEM that we are doing the operation of row for the
vector by specifying `OpFaceEle::OPROW`. Similarly for function `doWork()`, it
requires all three groups of the input but only one for each group instead of
two as we had for the stiffness matrix.

The implementation of this essential function of `doWork()` for force vector
calculation and assembling also has very similar structure to its matrix UDO
counterpart. The code for this function is as follows
\code
  MoFEMErrorCode doWork(int side, EntityType type, EntData &data) {
    MoFEMFunctionBegin;

    const int nb_dofs = data.getIndices().size();

    if (nb_dofs) {
      locRhs.resize(nb_dofs, false);
      locRhs.clear();

      // get element area
      const double area = getMeasure();

      // get number of integration points
      const int nb_integration_points = getGaussPts().size2();
      // get integration weights
      auto t_w = getFTensor0IntegrationWeight();

      // get base function
      auto t_base = data.getFTensor0N();

      // START THE LOOP OVER INTEGRATION POINTS TO CALCULATE LOCAL VECTOR
      for (int gg = 0; gg != nb_integration_points; gg++) {
        const double a = t_w * area;

        for (int rr = 0; rr != nb_dofs; rr++) {
          locRhs[rr] += t_base * body_source * a;

          // move to the next base function
          ++t_base;
        }

        // move to the weight of the next integration point
        ++t_w;
      }

      // FILL VALUES OF LOCAL VECTOR ENTRIES TO THE GLOBAL VECTOR

      // Ignoring DOFs on boundary (index -1)
      CHKERR VecSetOption(getKSPf(), VEC_IGNORE_NEGATIVE_INDICES, PETSC_TRUE);
      CHKERR VecSetValues(getKSPf(), data, &locRhs(0), ADD_VALUES);
    }

    MoFEMFunctionReturn(0);
  }
\endcode
Apart from the input arguments of this function is slight different from the UDO
for stiffness matrix, in this UDO for force vector, we use get the base function
value to calculate the components of local vector reflecting what is presented
in Eq. (4) and only need to loop over row DOFs as follows
\code
    // get base function
    auto t_base = data.getFTensor0N();
\endcode
and later using the constant body source (force) that predefined at the
beginning of the `*.hpp` to calculate the local vector
\code
        for (int rr = 0; rr != nb_dofs; rr++) {
          locRhs[rr] += t_base * body_source * a;

          // move to the next base function
          ++t_base;
        }
\endcode

Similar to the implemenation of matrix UDO, the final part of the code
involves filling/assembling the calculated values from local force vector to the
global one. This procedure for force vector is slightly different from the
matrix. It is done in two steps. First, we need to tell the program to ignore
the assembling of DOFs associated with boundary entities (marked as -1, \ref
show where and how to mark those DOFs) and assemble only DOFs associated with
the domain entities.
\code
CHKERR VecSetOption(getKSPf(), VEC_IGNORE_NEGATIVE_INDICES, PETSC_TRUE);
\endcode
And then assemble the local force vector to the global one using
\code
CHKERR VecSetValues(getKSPf(), data, &locRhs(0), ADD_VALUES);
\endcode
This is very similar to the previous case for matrix, but now `getKSPf()` is
used to set the value of the RHS vector later solved by [KSP](https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/index.html) iterative solver in PETSc.


That is all for the implementation of UDOs that are responsible for the
calculation and assembling of the LHS matrix \f$ {\bf K} \f$ and RHS vector \f$
{\bf F} \f$. Having the essential components implemented, you now may ask how
those UDOs is called in the main program. This is done through the process
called *push operator* to the **Pipeline** and you will find out in more details later in this tutorials,
\ref basic_tutorials_poisson_homogeneous_assemble.

Next part, we will look in details how the main program including class and
functions is implemented.



\subsection basic_tutorials_poisson_homogeneous_class The Poisson2DHomogeneous class

This main class Poisson2DHomogeneous contains functions and each of which is
responsible for a certain task of a finite element program.

The public part of the class include a constructor and function \ref
basic_tutorials_poisson_homogeneous_run_analysis that calls other functions to
perform finite element analysis.
\code
public:
  Poisson2DHomogeneous(moab::Core &mb_instance, MoFEM::Core &core);
  // Declaration of the main function to run analysis
  MoFEMErrorCode runAnalysis();
\endcode
Then there are private functions doing certain tasks and can be recognised by
their names
\code
private:
  // Declaration of other main functions called in runAnalysis()
  MoFEMErrorCode readMesh();
  MoFEMErrorCode setupProblem();
  MoFEMErrorCode setIntegrationRules();
  MoFEMErrorCode boundaryCondition();
  MoFEMErrorCode assembleSystem();
  MoFEMErrorCode solveSystem();
  MoFEMErrorCode outputResults();
\endcode
It is followed by the declaration of member variables that will be used in one
or some of the member functions declared above
\code
  // MoFEM interfaces
  MoFEM::Interface &mField;
  moab::Interface &mOab;
  Simple *simpleInterface;

  // mpi parallel communicator
  MPI_Comm mpiComm;
  // Number of processors
  const int mpiRank;

  // Discrete Manager and linear KSP solver using SmartPetscObj
  SmartPetscObj<DM> dM;
  SmartPetscObj<KSP> kspSolver;

  // Field name and approximation order
  std::string domainField;
  int oRder;
  MatrixDouble invJac;

  // MoFEM working Pipelines for LHS and RHS
  boost::shared_ptr<FaceEle> pipelineLhs;
  boost::shared_ptr<FaceEle> pipelineRhs;

  // Object needed for postprocessing
  boost::shared_ptr<FaceEle> postProc;
\endcode

\note For writting program in MoFEM, we follow some coding practices for code
style and naming convention described at \ref coding_practice



\subsubsection basic_tutorials_poisson_homogeneous_constructor Poisson2DHomogeneous()

Now is the constructor
\code
Poisson2DHomogeneous::Poisson2DHomogeneous(moab::Core &mb_instance,
                                           MoFEM::Core &core)
    : domainField("U"), mOab(mb_instance), mField(core),
      mpiComm(mField.get_comm()), mpiRank(mField.get_comm_rank()) {
  pipelineLhs = boost::shared_ptr<FaceEle>(new FaceEle(mField));
  pipelineRhs = boost::shared_ptr<FaceEle>(new FaceEle(mField));
}
\endcode
The constructor specifies
- `domainField("U")`: The domain field name as U (the field that we need to
  solve for solution)
- `mOab(mb_instance)`: The MOAB instance that helps MoFEM to manage element data
  and topology
- `mField(core)`: The MoFEM instance that is the backbone of the program
- `mpiComm(mField.get_comm())` and `mpiRank(mField.get_comm_rank())`: These are
  required for parallel computation

In the constructor, we also initialise two **Pipelines** `pipelineLhs` and
`pipelineRhs` to which two implemented UDOs for matrix \f$ {\bf K} \f$ and
vector \f$ {\bf F} \f$ will be pushed, respectively, as mentioned in the
previous section \ref basic_tutorials_poisson_homogeneous_udo.


  
\subsubsection basic_tutorials_poisson_homogeneous_readmesh readMesh()

Now the first function that actually do some finite element task is the function
responsible for reading input mesh
\code
MoFEMErrorCode Poisson2DHomogeneous::readMesh() {
  MoFEMFunctionBegin;

  CHKERR mField.getInterface(simpleInterface);
  CHKERR simpleInterface->getOptions();
  CHKERR simpleInterface->loadFile();

  MoFEMFunctionReturn(0);
}
\endcode
Apart from the codes for error handling, the main three lines of code
is a standard way to read a input mesh using Simple interface. Inteface in MoFEM
is a set of rules through which program developers use to setup a problem.
Simple interface provides simplest but also less flexible way to setup a
problem. More on the intefaces can be found at \ref
basic_lessons1_interfaces. Implementation of more advanced interfaces will be presented in later tutorials.

\subsubsection basic_tutorials_poisson_homogeneous_setupproblem setupProblem()
Next is the function that is responsible for setting up the finite element
problem 
\code 
MoFEMErrorCode Poisson2DHomogeneous::setupProblem() {
  MoFEMFunctionBegin;

  CHKERR simpleInterface->addDomainField(domainField, H1,
                                         AINSWORTH_BERNSTEIN_BEZIER_BASE, 1);

  int oRder = 3;
  CHKERR PetscOptionsGetInt(PETSC_NULL, "", "-order", &oRder, PETSC_NULL);
  CHKERR simpleInterface->setFieldOrder(domainField, oRder);

  CHKERR simpleInterface->setUp();

  MoFEMFunctionReturn(0);
}
\endcode
This function has
- `simpleInterface->addDomainField`: Add the field through the `simpleInterface`. This requires 
  - Field name (`domainField`), 
  - Approximation space (`H1`) - function space can also be `HCURL`,
    `HDIV`, `L2` depending on physical properties of the field you are approximating, see more at [FieldSpace](http://mofem.eng.gla.ac.uk/mofem/html/definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12)
  - Approximation bases (`AINSWORTH_BERNSTEIN_BEZIER_BASE`) - base can also be
    `AINSWORTH_LEGENDRE_BASE`, `AINSWORTH_LOBATTO_BASE`, `DEMKOWICZ_JACOBI_BASE
    `, see more at
    [FieldApproximationBase](http://mofem.eng.gla.ac.uk/mofem/html/definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5),
    and
  - Rank (`1`) as current problem is scalar-field problem. Rank will be `3` for
    vector-field problem.
- `simpleInterface->setFieldOrder`: Set the polynomial order of the approximation of the field
- `simpleInterface->setUp()`: Finally, do the setup of the problem.


\subsubsection basic_tutorials_poisson_homogeneous_intergration setIntegrationRules() 

This function is responsible for setting the Gauss integration rules and it
looks like this
\code
MoFEMErrorCode Poisson2DHomogeneous::setIntegrationRules() {
  MoFEMFunctionBegin;

  auto rule_lhs = [](int, int, int p) -> int { return 2 * (p - 1); };
  auto rule_rhs = [](int, int, int p) -> int { return p; };
  pipelineLhs->getRuleHook = rule_lhs;
  pipelineRhs->getRuleHook = rule_rhs;

  MoFEMFunctionReturn(0);
}
\endcode
Here \f$ p \f$ is the polynomial order of the approximation function. For
the LHS matrix, we are calculating the integral of function \f$\nabla \phi_i
\cdot \nabla \phi_j\f$ so the polynomial order of the integral is \f$ p - 1 \f$ 
plus \f$ p - 1 \f$ resulting \f$ 2 * (p - 1)\f$  as we see in the 
implementation of the integration rules for the LHS. Similarly, as we calculate 
the integral of \f$ \phi_i\f$ for the RHS, we use \f$ p \f$ as the integration 
rule of the RHS. Having the integration rules, MoFEM will automatically 
determine the number of integration (Gauss) points that need to be used for 
each entity (element).

\subsubsection basic_tutorials_poisson_homogeneous_bc boundaryCondition() 

This function helps to deal with the boundary condition and its
implementation for the current problem is as follows
\code
MoFEMErrorCode Poisson2DHomogeneous::boundaryCondition() {
  MoFEMFunctionBegin;

  // Get boundary edges marked in block named "BOUNDARY_CONDITION"
  Range boundary_entities;
  for (_IT_CUBITMESHSETS_BY_SET_TYPE_FOR_LOOP_(mField, BLOCKSET, it)) {
    std::string entity_name = it->getName();
    if (entity_name.compare(0, 18, "BOUNDARY_CONDITION") == 0) {
      CHKERR it->getMeshsetIdEntitiesByDimension(mField.get_moab(), 1,
                                                 boundary_entities, true);
    }
  }
  // Add vertices to boundary entities
  Range boundary_vertices;
  CHKERR mField.get_moab().get_connectivity(boundary_entities,
                                            boundary_vertices, true);
  boundary_entities.merge(boundary_vertices);

  // Remove DOFs as homogeneous boundary condition is used
  CHKERR mField.getInterface<ProblemsManager>()->removeDofsOnEntities(
      simpleInterface->getProblemName(), domainField, boundary_entities);

  MoFEMFunctionReturn(0);
}
\endcode
There is two parts of the implementation for the boundary condition for the
current problem of Poisson's equation with homogeneous boundary condition

- First, identify all the entities, from the input mesh, to which you would like
  to apply boundary condition. This is done in two steps
  - Getting the edges (up to faces for 3D problems) in the block that has
    been marked with a certain name, e.g. *BOUNDARY_CONDITION*, in the
    input mesh. So essentially, when creating the mesh, you select the edges
    where you want to apply boundary condition, you put those edges into one
    block and name that block making sure that the name in the mesh and in the
    code are matching. See more how to create the mesh having that properties
    from Gmsh at \ref basic_tutorials_mesh_generation_2d. The part of the codes
    that is responsible for this task is as follows
    \code
    // Get boundary edges marked in block named "BOUNDARY_CONDITION"
  Range boundary_entities;
  for (_IT_CUBITMESHSETS_BY_SET_TYPE_FOR_LOOP_(mField, BLOCKSET, it)) {
    std::string entity_name = it->getName();
    if (entity_name.compare(0, 18, "BOUNDARY_CONDITION") == 0) {
      CHKERR it->getMeshsetIdEntitiesByDimension(mField.get_moab(), 1,
                                                 boundary_entities, true);
    }
  }
    \endcode 

  - Including the vertices that are shared between the marked edges and the
    interior edges and faces to the set of entities on which boundary condition
    applies. We may normally forget this step but it is essential to have those
    vertices included, making sure the implementation of boundary condition
    correct and avoiding errors in results. The inclusion is done in this part
    of the code
    \code
    // Add vertices to boundary entities
  Range boundary_vertices;
  CHKERR mField.get_moab().get_connectivity(boundary_entities,
                                            boundary_vertices, true);
  boundary_entities.merge(boundary_vertices);
    \endcode

- Second, set the value of the boundary condition to the identified entities,
  i.e. (homogeneous) zero value boundary condition in this case. This process is
  simply done using the `removeDofsOnEntities()` function like this
  \code
  // Remove DOFs as homogeneous boundary condition is used
  CHKERR mField.getInterface<ProblemsManager>()->removeDofsOnEntities(
      simpleInterface->getProblemName(), domainField, boundary_entities);
  \endcode
  Of course, applying boundary condition for non-homogeneous boundary condition
  will not be this easy. We will show ways how to do it in MoFEM in other
  tutorials.

\subsubsection basic_tutorials_poisson_homogeneous_assemble assembleSystem() 

This part is about the function that responsible for the assembling of the
system of equations. As a reminder, at the beginning of the
section \ref basic_tutorials_poisson_homogeneous_implementation, we were
mentioning *two important concepts* in MoFEM, namely **UDO** and **Pipiline**.
While how the implementation of UDOs has been shown in \ref
basic_tutorials_poisson_homogeneous_udo, here you will see how the implemented
UDOs are *pushed* to the **Pipeline**

Apart from pushing UDOs to the main program, this function is also responsible
for setting operators for KSP solver (iterative linear solver provided by PETSc)
from the implemented pipelines. The full source code for the function is as follows
\code
MoFEMErrorCode Poisson2DHomogeneous::assembleSystem() {
  MoFEMFunctionBegin;

  { // Push operators to the Pipeline that is responsible for calculating LHS

    pipelineLhs->getOpPtrVector().push_back(
        new OpCalculateInvJacForFace(invJac));
    pipelineLhs->getOpPtrVector().push_back(new OpSetInvJacH1ForFace(invJac));

    pipelineLhs->getOpPtrVector().push_back(
        new OpDomainLhsMatrixK(domainField, domainField));
  }

  { // Push operators to the Pipeline that is responsible for calculating LHS

    pipelineRhs->getOpPtrVector().push_back(
        new OpDomainRhsVectorF(domainField));
  }

  // get Discrete Manager (SmartPetscObj)
  dM = simpleInterface->getDM();

  { // Set operators for linear equations solver (KSP) from MoFEM Pipelines

    boost::shared_ptr<FaceEle> null;
    CHKERR DMMoFEMKSPSetComputeOperators(dM, simpleInterface->getDomainFEName(),
                                         pipelineLhs, null, null);
    CHKERR DMMoFEMKSPSetComputeRHS(dM, simpleInterface->getDomainFEName(),
                                   pipelineRhs, null, null);
  }

  MoFEMFunctionReturn(0);
}
\endcode

- First, pushing the operators to the Pipeline that is responsible for the
calculation of the LHS matrix. This is done in two steps. Initially, the
operators to calculate the *inverse of the Jacobian* of the mapping from
reference (parent) space to the phyisical space is pushed first and then
the implemented UDO for stiffness matrix `OpDomainLhsMatrixK` is pushed to the 
pipeline, namely `pipelineLhs`.
\code
  { // Push operators to the Pipeline that is responsible for calculating LHS

    pipelineLhs->getOpPtrVector().push_back(
        new OpCalculateInvJacForFace(invJac));
    pipelineLhs->getOpPtrVector().push_back(new OpSetInvJacH1ForFace(invJac));

    pipelineLhs->getOpPtrVector().push_back(
        new OpDomainLhsMatrixK(domainField, domainField));
  }
\endcode
It is noted that the procedure to push operators calculting the inverse of
Jacobian with the presence of the gradient of approximation function is needed
only for 2D problem. For 3D problem, it is done automatically and user do not
have to manually add codes to push operators calculating the inverse of
Jacobian. This is because MoFEM was initially designed to solve 3D problems and
it made some adjustments along the way for solving 2D problems.

- Second, pushing the implemented UDO to Pipeline that is responsible for the
calculation of the RHS vector
\code
  { // Push operators to the Pipeline that is responsible for calculating LHS

    pipelineRhs->getOpPtrVector().push_back(
        new OpDomainRhsVectorF(domainField));
  }
\endcode
Here you can see, we do not need derivative of the approximation function to
calculate force vector in UDO `OpDomainRhsVectorF`. Consequently, the operators
for calculating inverse of Jacobian is not needed as well.

- Third, setting operators for KSP solver from the implemented pipelines, namely
  `pipelineLhs` and `pipelineRhs`
\code
  // get Discrete Manager (SmartPetscObj)
  dM = simpleInterface->getDM();

  { // Set operators for linear equations solver (KSP) from MoFEM Pipelines

    boost::shared_ptr<FaceEle> null;
    CHKERR DMMoFEMKSPSetComputeOperators(dM, simpleInterface->getDomainFEName(),
                                         pipelineLhs, null, null);
    CHKERR DMMoFEMKSPSetComputeRHS(dM, simpleInterface->getDomainFEName(),
                                   pipelineRhs, null, null);
  }
\endcode
Here we first get the Discrete Manager (DM) which is a common object allowing
things implemented in MoFEM talk to things implemented in PETSc. At this
particular point, Discrete Manager allows Pipelines (responsible for LHS and
RHS) implemented in MoFEM to be used later as the input for KSP solver
implemented in PETSc, through functions `DMMoFEMKSPSetComputeOperators` and
`DMMoFEMKSPSetComputeRHS` to set the computation of the LHS and RHS. From that,
the solution vector \f$ {\bf U} \f$ of the system of equations \f${\bf KU=F} \f$
will be obtained when the KSP solver is triggered at the later step \ref
basic_tutorials_poisson_homogeneous_solve.

\subsubsection basic_tutorials_poisson_homogeneous_solve solveSystem()
Having the computation of LHS and RHS is set in the previous function. We now
can actually solve the system of equations using iterative KSP solver from
PETSc.

The codes for the function that is responsible for solving the systems of
equations look like this
\code
MoFEMErrorCode Poisson2DHomogeneous::solveSystem() {
  MoFEMFunctionBegin;

  // Create RHS and solution vectors
  SmartPetscObj<Vec> global_rhs, global_solution;
  CHKERR DMCreateGlobalVector_MoFEM(dM, global_rhs);
  global_solution = smartVectorDuplicate(global_rhs);

  // Setup KSP solver
  kspSolver = createKSP(mField.get_comm());
  CHKERR KSPSetFromOptions(kspSolver);
  CHKERR KSPSetDM(kspSolver, dM);
  CHKERR KSPSetUp(kspSolver);

  // Solve the system
  CHKERR KSPSolve(kspSolver, global_rhs, global_solution);
  // VecView(global_rhs, PETSC_VIEWER_STDOUT_SELF);

  // Scatter result data on the mesh
  CHKERR DMoFEMMeshToGlobalVector(dM, global_solution, INSERT_VALUES,
                                  SCATTER_REVERSE);

  MoFEMFunctionReturn(0);
}
\endcode

It first starts with the initialisation of PETSc objects to store global RHS
vector and solution vector. Then, we setup the KSP solver which includes a step
to set up the DM that has been created in the previous function.
\code
CHKERR KSPSetDM(kspSolver, dM);
\endcode
This allows all the information in two Pipelines, `pipelineLhs` and
`pipelineRhs`, to be fed to the KSP solver. And then the system of equations is
solved and the solution is stored in the PETSc vector object `global_solution`
\code
  // Solve the system
  CHKERR KSPSolve(kspSolver, global_rhs, global_solution);
\endcode
Lastly, the results are scatttered through DM and ready to be fed to the output
mesh in the next step
\code
// Scatter result data on the mesh
  CHKERR DMoFEMMeshToGlobalVector(dM, global_solution, INSERT_VALUES,
                                  SCATTER_REVERSE);
\endcode


\subsubsection basic_tutorials_poisson_homogeneous_output outputResults() 

This function is solely responsible for the postprocessing of the results
writing the calculated field values to the output mesh.
\code
MoFEMErrorCode Poisson2DHomogeneous::outputResults() {
  MoFEMFunctionBegin;

  postProc = boost::shared_ptr<FaceEle>(new PostProcFaceOnRefinedMesh(mField));

  CHKERR boost::static_pointer_cast<PostProcFaceOnRefinedMesh>(postProc)
      ->generateReferenceElementMesh();
  CHKERR boost::static_pointer_cast<PostProcFaceOnRefinedMesh>(postProc)
      ->addFieldValuesPostProc(domainField);

  CHKERR DMoFEMLoopFiniteElements(dM, simpleInterface->getDomainFEName(),
                                  postProc);

  CHKERR boost::static_pointer_cast<PostProcFaceOnRefinedMesh>(postProc)
      ->writeFile("out_result.h5m");

  MoFEMFunctionReturn(0);
}
\endcode

\subsubsection basic_tutorials_poisson_homogeneous_run_analysis runAnalysis() 

Finally, having all the necessary tasks implemented in the corresponding
functions, we can now put them together in the last function of the main class.
This function is responsible for the calling sequence which is similar to most
of other finite element programs
\code
MoFEMErrorCode Poisson2DHomogeneous::runAnalysis() {
  MoFEMFunctionBegin;

  readMesh();
  setupProblem();
  setIntegrationRules();
  boundaryCondition();
  assembleSystem();
  solveSystem();
  outputResults();

  MoFEMFunctionReturn(0);
}
\endcode

\subsection basic_tutorials_poisson_homogeneous_main_function The main() function

This `main()` function does not do much job apart from creating the top-level
class and call the function to trigger the analysis 
\code
int main(int argc, char *argv[]) {

  // Initialisation of MoFEM/PETSc and MOAB data structures
  const char param_file[] = "param_file.petsc";
  MoFEM::Core::Initialize(&argc, &argv, param_file, help);

  // Error handling
  try {
    // Register MoFEM discrete manager in PETSc
    DMType dm_name = "DMMOFEM";
    CHKERR DMRegister_MoFEM(dm_name);

    // Create MOAB instance
    moab::Core mb_instance;              // mesh database
    moab::Interface &moab = mb_instance; // mesh database interface

    // Create MoFEM instance
    MoFEM::Core core(moab); // finite element database
    // MoFEM::Interface &m_field = core; // finite element interface

    // Run the main analysis
    Poisson2DHomogeneous poisson_problem(mb_instance, core);
    CHKERR poisson_problem.runAnalysis();
  }
  CATCH_ERRORS;

  // Finish work: cleaning memory, getting statistics, etc.
  MoFEM::Core::Finalize();

  return 0;
}
\endcode
So you can see, at the beginning, it creates the Discrete Managers that enable
information flows between MoFEM (finite element implementation), MOAB (element
topology management), and PETSc (algebraic solvers). After that, it creates
variable `poisson_problem` of type/class `Poisson2DHomogeneous` which is
previously defined and then run the analysis by triggering the public function runAnalysis().
\code
    // Run the main analysis
    Poisson2DHomogeneous poisson_problem(mb_instance, core);
    CHKERR poisson_problem.runAnalysis();
\endcode


\section basic_tutorials_poisson_homogeneous_result Results

\subsection basic_tutorials_poisson_homogeneous_run_program Run the program

In order to run the program that we have been discussing in this tutorial, you
will do the following steps
- First, go to the directory where the binary file `poisson_2d_homogeneous` is
  located. Depending on how you install MoFEM shown in this page \ref
  installation, going to the directory would be something similar to this 
  - For user version installation
    \code
    cd mofem_install/um_view/tutorials/poisson/
    \endcode
  - For developer version installation
    \code
    cd mofem_install/um/build_release/basic_finite_elements/tutorials/poisson
    \endcode

- Second, check the parameters in the param_file.petsc. These are PETSc
  parameters and you should only use parameters that needed for a particular
  solver, in this case KSP solver. Only the following parameters should be
  uncommented
  \code
  ## Linear solver
  -ksp_type fgmres 
  -pc_type lu 
  -pc_factor_mat_solver_type mumps
  -ksp_monitor
  \endcode
- Third, in the terminal, run commands to partition the input mesh and start
  the analysis
  \code
  mofem_part -my_file mesh2d.cub -output_file mesh2d.h5m -my_nparts $NPROCS -dim 2 -adj_dim 1
  mpirun -np $NPROCS ./poisson_2d_homogeneous -file_name mesh2d.h5m -order $APPROX_ORDER -log_quiet
  \endcode
  where `$NPROCS` is the number of processors you would like to use to run the
  analysis and `$APPROX_ORDER` denotes the polynomial order of the approximation
  function.

\subsection basic_tutorials_poisson_homogeneous_op Output

Once the analaysis is complete, you see all output messages are printed to the
terminal
- Version of MoFEM used to run the analysis
\code
MoFEM version 0.9.2 (MOAB 5.1.0 Petsc Release Version 3.11.3, Jun, 26, 2019 )
git commit id c7dec267e3dc854dfdd62fff66ecd3119ec940cc
\endcode
- Meshset and entity block defined in the input mesh
\code
read cubit meshset 12682136550675316746 type BLOCKSET UNKNOWNNAME msId 1 name BOUNDARY_CONDITION block header:  blockCol = 4294967295 blockMat = 0 blockDimension = 1
\endcode
- Domain field name, approximation space and bases, as well as rank (1 for
  scalar problem) as implemented in \ref   basic_tutorials_poisson_homogeneous_setupproblem
\code
Add field U field_id 1 space H1 approximation base AINSWORTH_BERNSTEIN_BEZIER_BASE rank 1 meshset 12682136550675316749
Add finite element dFE
\endcode
- General information about the problem including removing DOFs associated with
  the boundary
\code
Add probken SimpleProblem
Number of dofs 3001
Finite element dFE added. Nb. of elements added 232
Number of adjacencies 1624
SimpleProblem Nb. local dof 3001 by 3001 nb global dofs 3001 by 3001
 FEs ghost dofs on problem SimpleProblem Nb. ghost dof 0 by 0 Nb. local dof 3001 by 3001
removed ents on rank 0 from problem SimpleProblem dofs [ 2801 / 2801  (before 3001 / 3001) local, 0 / 0 (before 0 / 0) ghost, 2801 / 2801 (before 3001 / 3001) global]
\endcode
- Convergence of the KSP iterative solver from PETSC. As shown, it is converged
  is one step which is expected for this simple linear problem.
\code
  0 KSP Residual norm 1.109112371166e+01 
  1 KSP Residual norm 2.268250563795e-14
\endcode


Then, you will also see in the directory where you run the analysis, it now has
the newly created output file, namely `out_result.h5m`. The output can be
visualised in an visualisation software. If you would like to open the output in
the free software of [Paraview](https://www.paraview.org), you would need to
convert the input file to `*.vtk` format by running the following command line
in your terminal
\code
mbconvert out_result.h5m out_result.vtk
\endcode
Then open it in Paraview and use the filter `WarpByScalar`, you will be able to
see the deformation as below

\anchor figure_poisson_homogeneous
\image html poisson_homogeneous.png "Figure 1: Poisson homogeneous visualisation." width = 900px


\subsection basic_tutorials_poisson_homogeneous_discussion Discussion

As mentioned at the begining of this tutorial, this Poisson
equation with homogeneous boundary condition helps to predict the deformation
of a membrane that is fixed at the boundary bearing an uniformly distributed
force on its surface. In this case, the force \f$ f=5.0\f$ is hardcoded in the
code.

You can test yourself how the increase/decrease in approximation order affect
the number of DOFs and the analysis time. Also, you can do the same
investigation but by changing the mesh density.

Regarding the implementation in MoFEM, it is important that you get the concept
of developing/using **UDOs** to evaluate the matrices and vectors and then push
them, in a certain order, to the **Pipelines** where calculations are done
sequentially. These concepts will apply to all of the programs implemented in
MoFEM. 

\subsection basic_tutorials_poisson_homogeneous_extension Possible extension

With the implementation for 2D problem is done, you can effortlessly extend it
to solve 3D problem with few changes as follows

- Change all `Face` to `Volume` (`.cpp` and `.hpp` files)
  - Using `PostProcVolumeOnRefinedMesh` instead of `PostProcFaceOnRefinedMesh`
  - Using `VolumeElementForcesAndSourcesCore` instead of `FaceElementForcesAndSourcesCore`

- Change FTensore objects that have two components to three (`.hpp` file)
  - Using `FTensor::Index<'i', 3> i;` instead of `FTensor::Index<'i', 2> i;`
  - Using `getFTensor1DiffN<3>` instead of `getFTensor1DiffN<2>`

- No need to specifically calculate inverse of Jacobian in 3D case, it is done
  automatically behind the curtain (`.cpp` file)
  \code
  // MatrixDouble invJac;
  // pipelineLhs->getOpPtrVector().push_back(
  //     new OpCalculateInvJacForFace(invJac));
  // pipelineLhs->getOpPtrVector().push_back(new OpSetInvJacH1ForFace(invJac));
  \endcode

- [Optional] Objects' name changed for readability (`.cpp` and `.hpp` file)
  - Using `Poisson3DHomogeneous` instead of `Poisson2DHomogeneous`
  - Using `Poisson3DHomogeneousOperators` instead of `Poisson2DHomogeneousOperators`
  - Using `volume` instead of `area`

You can find the complete code to solve 3D version of the Poisson problem with
homogeneous boundary condition in poisson_3d_homogeneous.hpp and poisson_3d_homogeneous.cpp

To run the analysis, you will follow very similar procedure as for the 2D case
using the same `param_file.petsc` file with slight changes in the command lines
\code
  mofem_part -my_file mesh3d.cub -output_file mesh3d.h5m -my_nparts $NPROCS -dim 3 -adj_dim 1
  mpirun -np $NPROCS ./poisson_3d_homogeneous -file_name mesh3d.h5m -order $APPROX_ORDER -log_quiet
\endcode


\section basic_tutorials_poisson_homogeneous_plain_program Plain program 


The plain program for both the implementation of the UDOs (\c *.hpp) and the
main program (\c *.cpp) are as follows

\subsection basic_tutorials_poisson_homogeneous_impl_udo Implementation of User Data Operators (*.hpp)

\include poisson_2d_homogeneous.hpp

\subsection basic_tutorials_poisson_homogeneous_impl_main Implementation of the main program (*.cpp) 

\include poisson_2d_homogeneous.cpp




*/
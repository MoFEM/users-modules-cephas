/*! \page basic_lessons1 Integration on finite element mesh

\note Draft version

\section basic_lessons1_intro Introduction

The first lesson is solely committed to numerical integration. Integration is essential for most of the numerical methods (except for the collocation method) used to solve partial differential equations (PDEs).

The most straightforward interpretation of the finite element method is considering it as a method for integration of functions on complex shapes. The integration domain is divided into elements with primitive shapes, e.g. edge, triangle, quad, tetrahedron, or hexahedron, and on each element integration rule for the primitive shape is evaluated. Thus a complex problem is broken into many simple elements, on which the same simple procedure is executed over and over. Such repeatable tasks make it a perfect method for a computer.

We will present the problem of numerical integration by calculating moments of inertia. Moments of inertia characterise the distribution and amount of the mass in the body and have various engineering applications. 

First, we explain essentials, then provide a definition of the moments of inertia. Next section is dedicated to the theory, and finally we show details of implementation in MoFEM. 

\section basic_lessons1_start Essentials

\subsection basic_lessons1_simplexes Integration on simplexes

\note In geometry, a simplex is a generalization of the notion of a triangle or tetrahedron to arbitrary dimensions. Note that an edge is also considered as a particular case of the simplex, see <a href="https://en.wikipedia.org/wiki/Simplex">Simplex</a> for more details.

Numerical integration of a function \f$\rho(x)\f$ is given by the following general formula:
\f[
\begin{align}
\label{eq:num_int}
  I(\rho) = \int_\Omega \rho\,\textrm{d}\Omega \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} W_g\|\mathbf{J}_g^e\|\rho^e_g
\end{align}
\f]
where \f$W_g\f$ is the integration weight, \f$\|\mathbf{J}_g^e\|\f$ is the determinant of the Jacobian of the \f$e\f$-th element's transformation from the local coordinate system to the Cartesian one, \f$\rho^e_g\f$ is the value of the function at \f$g\f$-th integration point, \f$G\f$ is the number of integration points per each element, and \f$N\f$ is the total number of elements in a mesh. Typically, the sum of the integration weights equals to unity:
\f[
\begin{align}
  \sum_{g=0}^{G-1} W_g = 1.
\end{align}
\f]
Furthermore, for the case of simplexes the numerical integration formula \eqref{eq:num_int}   takes a more straightforward form:

- For a tetrahedron
\f[
\begin{align}
  I(\rho) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} (W_g v) \, \rho^e_g,
\end{align}
\f]
where \f$v\f$ is the volume of an element (tetrahedron); 

- For a triangle
\f[
\begin{align}
  I(\rho) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} (W_g a) \, \rho^e_g,
\end{align}
\f]
where \f$a\f$ is the area of an element (triangle);

- For an edge
\f[
\begin{align}
  I(\rho) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} (W_g \ell) \, \rho^e_g,
\end{align}
\f]
where \f$\ell\f$ is the length of a line element (edge).

In the following sections we explain how the above sums are evaluated and give some additional details about the Jacobian.  


\tableofcontents

\subsection basic_lesson1_moments Moments of inertia

The distribution of mass in the body can be characterised by moments of inertia. Moments of inertia have practical applications, they are used for analysis of motion of rigid bodies, or to characterise cross-section area in the structural analysis. 

In general, moments of inertia are tensors. Zero moment is represented by a single scalar coefficient, first moment is a 1D array, i.e.  a vector of coefficients, and second moment is a second-order tensor, coefficients of which for convenience can be organised in a 2D table, i.e. a matrix. Note that these coefficients depend on the observer, i.e. coordinate system, and the tensorial transformation rule describes how coefficients of moments of inertia change with the observer. 

- Zero inertia moment is the body mass, 
\f[
\begin{align}
M := \int_\Omega \rho(\mathbf{x}) \, \textrm{d}\Omega,
\end{align}
\f]
where \f$\rho\f$ is the material density, and \f$\Omega\f$ is a body domain.
Mass characterises how much force needs to be applied for a desired body
acceleration \f$\mathbf{a}=\{a^i\}\f$ as stated by the Newton's law:
\f[
\begin{align}
a^i = M f^i,
\end{align}
\f]
where \f$\mathbf{f}=\{f^i\}\f$ is the force. Moreover, kinematic energy can be expressed as:
\f[
\begin{align}
E_k = \frac{v^i M v^i}{2},
\end{align}
\f]
where \f$\mathbf{v}=\{v^i\}\f$ is the velocity, and the summation over repeating indices is assumed. 
Note also, that for the zero moment the tensorial transformation rule is straightforward: the mass of an object cannot be changed by looking at it from different points and angles, so it is the same in every coordinate system.

- First inertia moment is given by:
\f[
\begin{align}
S^i := \int_\Omega \rho(\mathbf{x}) \, x^i \textrm{d}\Omega
\end{align}
\f]
where \f$x^i\f$ is the coordinate in the \f$i\f$ direction. Center of gravity of the body can be calculated as:
\f[
\begin{align}
x_c^i = \frac{S^i}{M}.
\end{align}
\f]
where \f$\mathbf{x}_c=\{x_c^i\}\f$ is the centre of gravity of the body, or system of bodies. Note that if the origin is placed at the centre of gravity, then the first moment of inertia is zero.

- Second moment of inertia is defined as:
\f[
\begin{align}
I^{ij} := \int_\Omega \rho(\mathbf{x}) \left(x^ix^j\right) \textrm{d}\Omega
\end{align}
\f]
where \f$(x^ix^j)\f$ is the <a href="https://en.wikipedia.org/wiki/Outer_product">Outer product</a>. The second moment of inertia, analogously to mass, characterises how much torque has to be applied at body origin for desired body angular acceleration \f$\boldsymbol\alpha=\{\alpha^i\}\f$, as follows:
\f[
\begin{align}
\alpha^i = I^{ij} \tau^j = I^{ij} (\varepsilon^{jmn} x^m f^n)
\end{align}
\f]
where \f$\boldsymbol\tau=\{\tau^j\}\f$ is the torque vector, and \f$\varepsilon^{jmn}\f$ is the <a href="https://en.wikipedia.org/wiki/Levi-Civita_symbol">Levi-Civita symbol</a>, while the term in brackets is the cross product of the force vector and arm on which this force acts. Finally, the kinematic energy of the rotating body is 
\f[
\begin{align}
E_k = \frac{\omega^i I^{ij} \omega^j}{2}.
\end{align}
\f]

\section basic_lessons1_theory Theory 

This section is not essential, you can skip it and come back later for a more in-depth understanding of the problem, move to implementation.

\subsection basic_lessons1_elements Integral over elements

The integral of function \f$\rho(\mathbf{x})\f$, where coordinate \f$\mathbf{x}\in V\f$, is a sum of integrals over all primitives shapes (elements) constituting whole integral domain 
\f[
\begin{align}
  I(\rho) = \int_V \rho(\mathbf{x}) \textrm{d}V \approx \int_{V^h} \rho(\mathbf{x}^h) \textrm{d}V = \sum_{e=0}^{N-1} \int_{\mathcal{T}^e} \rho(\mathbf{x}^h) \textrm{d}V = \sum_{e=0}^{N-1} I_\mathcal{T}
\end{align}
\f]
You may note that in the above equation value of integral is approximated since the domain of integration is not exact, and represented by a mesh. Mesh is assembled from non-overlapping elements, see mesh on the right of \ref basic_l1_figure_1 "Figure 1". Taking a closer look at \ref basic_l1_figure_1 "Figure 1", you can see that geometry is complex, and contains patches from a sphere and some edges are circles. Those are not precisely circles, and not exactly part of the surface of the sphere since volume and its skin are represented by tetrahedrons and triangles respectively. Those elements have a straight edge, so there is some difference between the mathematical model and its finite element discretisation. However, it is good news that error, i.e. difference between the mathematical model and discretisation can be controlled. You can refine the mesh until error becomes small enough, as small as you need. From the other hand, if the surfaces of the body are flat, and edges are straight, the volume is approximated exactly. One can also generalise, and describe edges of elements by polynomials of second and higher-orders, that also enables control of the geometry error. However, in this tutorial, we restrict ourselves, and geometry will be represented by linear <em>Shape Functions</em>. For the rest of the tutorials, we will be using \f$(\cdot)^h\f$, to indicate that given quantity is approximated, and thus there is some error associated with the approximation.

\anchor basic_l1_figure_1
\image html basic_shape_function.png "Figure 1: Finite element mesh shape functions, and integration points" width=800px

\subsubsection basic_lessons1_rule Integration in the element

Integration on each element, applying integration formulae, is as follows:
\f[
\begin{align}
  I_\mathcal{T} = 
  \int_{\mathcal{T}^e} \rho(\mathbf{x}) \textrm{d}V \approx
  \sum_{g=0}^{G-1} W_g \rho\left(\mathbf{x}^h(\pmb\xi_g)\right) \| \mathbf{J}_g \| =
  \sum_{g=0}^{G-1} W_g \rho^h_g \| \mathbf{J}_g \| =
  \sum_{g=0}^{G-1} w_g \rho^h_g
\end{align}
\f]
where \f$\rho_g\f$ is value of integrated function at integrated point \f$\pmb\xi_g\f$ and \f$w_g=\| \mathbf{J}_g \| W_g\f$ is integration weight, see \ref basic_l1_figure_2 "Figure 2". You can see, that integral is expressed simply as the sum of function values at integration multiplied by weights, something which can be easily implemented as a computer program. For a given <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature">Gauss quadrature</a>  polynomials can be calculated exactly up to order of integration rule \f$r\f$, without any numerical error. So the only error of integration comes from the fact that integrated function is approximated, i.e. \f$\rho_g \approx \rho_g^h\f$. If the function is analytical, the order of error is of\f$O(h^r)\f$, where \f$h\f$ is the size of the element. We will discuss how to choose the integration rule on an element in the next lesson.

\anchor basic_l1_figure_2
\image html basic_lesson1_integration_pt_lesson1.png "Figure 2: Integration points on element" width=600px

For integration on simplexes, i.e. (vertices), edges, triangles, tetrahedra, usually for convenience and efficiency, integration points are given by <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">barycentric coordinates</a> \f$\pmb\lambda\f$, see left of \ref basic_l1_figure_3 "Figure 3". For quadrilaterals, like quads and hex, quadrature points are constructed by the tensor product of integration rules in 1D, see right of \ref basic_l1_figure_3 "Figure 3". One can construct integration for other elements shapes, for prisms by the tensor product of integration on triangle and line. For other shapes like for wedge, one can use Duffy transform. Duffy integration is constructed from hexahedron integration rule; then nodes are collapsed. Such procedure degenerate hexahedron, for example, to wedge. In other words, the reference element is hexahedron, but the physical element is a wedge. 

Finally,  in the end, we will use the integration rule from the shelf. However, at the moment, no matter what is the shape of a finite element, or how iteration points and weight are calculated. We have to remember the numerical integration will be the sum of integration weights multiplied by function values at integration points, and we are using that in this lesson.  Implementation of such integration is trivial, with the use of a single loop.

\anchor basic_l1_figure_3
\image html basic_shape_function_quad_and_tri.png "Figure 3: Shape functions on triangle and quadrilateral" width=800px

\subsubsection basic_lessons1_approx Approximation of density field

The remaining question is how to evaluate field \f$\rho(\mathbf{x}^h_g)\f$ at integration points? In this case
\anchor lesson1_approx_rho
\f[
\begin{align}
  \rho_g = \rho(\mathbf{x}^h(\pmb\xi_g)) 
  \approx \rho^h_g = \sum_{m=0}^{M-1} \mathcal{N}_m(\pmb\xi_g) \overline{\rho}^m
\end{align}
\f]
where \f$\rho^h_g\f$ is interpolated value at integration point \f$\pmb\xi_g\f$, \f$\mathcal{N}_m\f$ is shape function at node \f$m\f$, \f$M\f$ is number of nodes on the element, see \ref basic_l1_figure_4 "Figure 4", and \f$\overline{\rho}_i\f$ is value of function \f$\rho(\mathbf{x}_i)\f$ at node \f$i\f$ with coordinates \f$\mathbf{x}_i\f$. Note that finite  element interpolate function \f$\rho(\mathbf{x})\f$, since at nodes 
\f$\overline{\rho}_i = \rho(\mathbf{x}_i)\f$, and between nodes function is 
approximated. For linear shape functions, as in \ref basic_l1_figure_3 "Figure 3", approximation error is order of \f$O(h^2)\f$, where \f$h\f$ is size of element (mesh). The symbol big \f$O\f$ is a mathematical notation that describes how the error changes when the mesh size changes. In this particular case, it means that for every reduction of mesh size by ten times, approximation error reduces one hundred times. By making mesh smaller, the error of approximation can be controlled to achieve desired accuracy. It is another way to improve the quality of the approximation and achieve arbitrary error order, that is \f$O(h^{p+1})\f$. That 
can be achieved by using higher-order polynomials to approximate function \f$\rho\f$, see for more details here \ref hierarchical_approximation_1.

\note A numerical method does not have to be exact (if it is that is great), but it is not the holy grail. We always aim for the method to be consistent, i.e. solution coverage to the exact solution, converges fast, and is robust, i.e. can solve real problems, not academic exercises. 

\subsubsection basic_lessons1_map Mapping reference and physical element

\anchor basic_l1_figure_4
\image html basic_map.png "Figure 4: Map reference element to physical element" width=700px

 \ref basic_l1_figure_4 "Figure 4" presents a map between the reference element (red triangle) and element in physical configuration (blue triangle). Maps transform, shift, rotate and stretch element (see \ref basic_l1_figure_4 "Figure 4"), and establish one to one relation (at least for all points without element boundary) between coordinates in reference element \f$\pmb\xi\f$ and physical coordinates \f$\mathbf{x}\f$ as follow
\anchor lesson1_map
\f[
\begin{align}
  x_i^h (\pmb\xi) = 
  \sum_{m=0}^{M-1} \mathcal{N}_m(\pmb\xi) \overline{x}^m_i 
\end{align}
\f]
 Equation \ref lesson1_map "(17)" is not very different from equation \ref
 lesson1_approx_rho "(16)", the only difference is that is evaluated for every
 coefficient  \f$i=0..(d-1)\f$, where  \f$d\f$ is the dimension of the problem,
 e.g. for 3D problem \f$d=3\f$. 

\subsubsection basic_lessons1_jacobian Jacobian

Note that integration over the physical element is problematic; it is much easier to construct integration rule on the reference element and integrate on it. To change the integration domain from physical element to the reference element, the concept of a map, the tangent map, and Jacobian, is useful, to change physical integration coordinates to reference coordinates. Calculation of integration rule for an element can be complicated and time-consuming, however, if the rule on reference element is used, it can be precalculated and stored in the table to be used for all elements on the mesh.

From \ref basic_l1_figure_4 "Figure 4" we can see that infinitesimal local element can be mapped to element in physical space by mapping infinitesimal vectors \f$d\pmb\xi_i\f$ into \f$d\mathbf{x}_i\f$. Expanding such map at point \f$\mathbf{q}\f$ into Taylor series, we get
\anchor baic_taylor_expansion
\f[
  \begin{align}
  \mathbf{x}_\mathbf{q}^i = 
  \mathbf{x}_\mathbf{p}^i + d\mathbf{x}^i = 
  \mathbf{x}_\mathbf{p}^i + J^{ij}(\pmb\xi_\mathbf{P}) d\pmb\xi^j + O(\|d\pmb\xi\|^2)
  \end{align}
\f]
where Jacobian is
\f[
  \begin{align}
  J^{ij}(\pmb\xi_\mathbf{P})  = 
  \sum_{m=0}^{M-1} \left.
  \frac{\partial \mathcal{N}_m}{\partial \xi_j}
  \right|_\mathbf{P} \overline{\mathbf{x}}^m_i
  \end{align}
\f]
In eq. \ref baic_taylor_expansion "(18)", higher-order term on the right can be omitted, since we focus attention on infinitesimal elements in reference element and physical element, that is  \f$dA\f$ and \f$da\f$, respectively. For example element \f$dA\f$ has size \f$\|d\pmb\xi\| \ll 1 \f$ and can be assumed that \f$\|d\pmb\xi\|^2 = 0\f$, without making any error. Note that once the higher-order terms are omitted, equation mapping domain in vicinity of point in reference element into the domain in vicinity of the physical element is linear. This is called the tangent map since it is accurate only for in the vicinity of the tangent point. Like a tangent plane pinned to the earth, glob can represent distances accurately between locations only in the small range from where it is pinned. 

Using above derivation for Jacobian, in general 3D case, i.e. tetrahedron, or hexahedron, infinitesimal element volume at integration point \f$g\f$ in physical configuration can be expressed as
\f[
\begin{align}
  dv = 
  \left| d\mathbf{x_2}^k (\varepsilon^{ijk} d\mathbf{x_0}^i d\mathbf{x_1}^j) \right| 
  =
  \left| \varepsilon^{ijk} J^{i0} J^{j1} J^{k2} \left(d\pmb\xi_0 d\pmb\xi_1  d\pmb\xi_2 \right) \right| 
  =
  \| \mathbf{J} \| dV
\end{align}
\f]
taking \f$d\pmb\xi_0\f$, \f$d\pmb\xi_1\f$, and \f$d\pmb\xi_2\f$, are cartesian base vectors and \f$\varepsilon\f$ is Levi-Civita tensor. \f$J^{i0}\f$, \f$J^{j1}\f$, and \f$J^{k2}\f$ are columns of Jacobian evaluated at integration point \f$\pmb\xi_g\f$. The connection between Levi-Civita tensor and Jacobian determinant can found <a href="https://en.wikipedia.org/wiki/Levi-Civita_symbol#Determinants">here</a>. Note that for lower dimensions above equation holds. Finally, we have everything necessary to calculate integral on finite element mesh
\f[
\begin{align}
  I(f) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} W_g \| \mathbf{J}_g \| \rho^h_g
\end{align}
\f]

\note You can learn more about integration from \cite zienkiewicz1977finite.

\note No one person invented the finite element method, but it roots in the invention of Shape Functions and isoparametric finite elements by <a href="https://en.wikipedia.org/wiki/Bruce_Irons_(engineer)">B. M. Irons</a> along with Ian C. Taig.

\section basic_lesson1_implementation Implementation

\subsection basic_lesson1_installations Installation

If you want to develop code in MoFEM, and you probably do if you are reading this tutorial, you will need to install developer version of MoFEM following instructions here \ref install_spack.

Executable files are located in
\code
$HOME/mofem_install/um/build_debug/basic_finite_elements/basic
\endcode
whereas the source code is located in 
\code
$HOME/mofem_install/mofem-cephas/mofem/users_modules/basic_finite_elements/basic
\endcode
This is called `out-of-source compilation` since code and programs are located in two different locations. It is a convenient way if you have different compilation options or linking different libraries, and you would like to test to test them all against the same source code. Code in \em build_debug is compiled with debugging flags and is not optimised. Using the debugger you can run such code line by line, which can help you understand how it works and find errors in your code. Information on how to debug code can be found
<a href="https://code.visualstudio.com/docs/introvideos/debugging">here</a>.

\note In the default MoFEM installation you can create executables under another location which is
\code 
$HOME/mofem_install/um/build_release/basic_finite_elements/basic
\endcode
Executable files \em build_release location are optimised, and are running much faster but are also harder to inspect with the debugger. 

\subsection running_lesson_1 Running code

To run code type
\code
cd $HOME/mofem_install/build_release/basic_finite_elements/basic
./basic_moment_of_inertia -file_name cube.h5m
\endcode

Code is executed for the cube mesh, see \ref basic_lesson1_figure5 "Figure 5", which has unit size for all edges and coordinates origin is in the centre of the cube. 
\anchor basic_lesson1_figure5
\image html basic_lesson1_cube.png "Figure 5: Cube" width=700px

Code output should be similar to the following:
\code
MoFEM version 0.9.1 (MOAB 5.1.0 Petsc Release Version 3.11.3, Jun, 26, 2019 ) 
git commit id 9b6655832763d7fc44c80e01d36bae166a69ed80
add: name rho BitFieldId 1 bit number 1 space H1 approximation base AINSWORTH_LEGENDRE_BASE rank 1 meshset 12682136550675316764
add finite element: dFE
add problem: SimpleProblem
Build Field rho (rank 0)
nb added dofs (vertices) 64 (inactive 0)
nb added dofs 64 (number of inactive dofs 0)
Nb. dofs 64
Build Finite Elements dFE
id 00000000000000000000000000000001 name dFE f_id_row 00000000000000000000000000000001 f_id_col 00000000000000000000000000000001 BitFEId_data 00000000000000000000000000000001 Nb. FEs 162
Nb. entFEAdjacencies 2430
partition_problem: rank = 0 FEs row ghost dofs problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. local dof 64 nb global row dofs 64
partition_problem: rank = 0 FEs col ghost dofs problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. local dof 64 nb global col dofs 64
problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. elems 162 on proc 0
partition_ghost_row_dofs: rank = 0 FEs row ghost dofs problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. row ghost dof 0 Nb. local dof 64
partition_ghost_col_dofs: rank = 0 FEs col ghost dofs problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. col ghost dof 0 Nb. local dof 64
Mass 1.0000e+00
First moment of inertia [ -4.3368e-19, -1.4095e-17, -1.3878e-17 ] 
Second moment of inertia [ 3.4961e-312, 1.0000e+00, 0.0000e+00; 6.9531e-310 8.3333e-02; -6.0715e-18 ]
\endcode

The code prints at the beginning the version of the MoFEM library. In the same
line, versions of MOAB and PETSc are printed respectively. This will enable to
reproduce errors if occurred and fix bugs. Next information printed is about
elements added, i.e. \em dFE, and field DOFs for density field, i.e. \em
rho. Here only DOFs on vertices are added. Thus linear approximation of density
is considered. After that, the information about the number of finite elements
is printed, i.e. 162, and the problem itself, i.e. SimpleProblem, the number of
DOFs on rows & columns, i.e. 64, and other information related to mesh
partitioning. Finally, the results are printed.


\subsection basic_lesson1_programming Editor

You can use your favourite editor, vim, emacs, sublime, atom.io, if you have
one, however, if you have no preferences we recommend <a
href="https://code.visualstudio.com">VS Code</a>. We have some tips on how you
can configure it to make it work well with MoFEM, see \ref configure_vs_code.

\note We have some programming conventions, and style of programming, see \ref
coding_practice. You do not have to jump and learn conventions; you will pick-up
style on the way like children pick-up cultural conventions when they grow up.
In MoFEM, we are using clang-format to help us unify programming style. Most of
the editors use clang-format. For example, how to do that in VS Code is described
<a href="https://code.visualstudio.com/docs/cpp/cpp-ide">here</a>. Keeping the
same style, and learning and following programming conventions is essential in
the long term. MoFEM is open community code, and if everyone follows the agreed
style, it improves code readability, and people understand each other better. 

\subsection basci_lesson1_main Main function

The main function is relatively short and looks the same for any program in this set of tutorials.
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp  main

You can use the above snippet to start your code. The main function is responsible for kick-starting the job, and it has stages;

- The main programme begins with registering MoFEM DM interface in PETSc data structures. That enables transparent control of MoFEM database by PETSc solvers, and vice-versa use PETSc standard interface to create matrices, vectors, and other PETSc objects

- Next, the MOAB database is created and connected to the interface. A similar approach is made for MoFEM database. MOAB database stores data about mesh, whereas MoFEM database stores data about finite element method, approximation bases, finite elements and problems. MoFEM is another level of abstraction, on top of the MOAB database since finite element data are stored on data tags created on mesh entities. 

- Finally, problem-specific example class is created, and calculations are executed in Example::runProblem.

\subsection basci_lesson1_error_handling Error handling

Errors are caught at the end, see 
\code
try {

  // Some code here

}
CATCH_ERRORS;
\endcode
This part of the code is responsible for handling all the errors, initiated inside PETSc, MOAB, Boost, standard library, and MoFEM or developer functions. PETSc, MOAB, and MoFEM functions return error code, to handle them properly, do as follow
\code
  CHKERR PetscFunction();   // PETSc function
  CHKERR moab.function();   // MOAB function
  CHKERR m_field.function(); // MoFEM function
\endcode
Catching errors will make searching for runtime errors easier, and in case of
the problem appearing, for seeking help, see \ref guidelines_bug_reporting. CHKERR is a macro which check error code returned by the function, and if returned code indicates an error, program stops and prints the relevant error.

\note When you program, you can encounter two types of error, <em>compilation
errors</em> and <em>runtime errors</em>. <em>Compilation errors</em> are most
often a syntax error, which prevents the compiler from making program, you see
them when you run \em make programme. <em>Runtime errors</em> are caused by some
bug in the programme such as segmentation-fault, overflow, bad algorithm or you
run out of computer resources, e.g. memory. Those errors need to be handled, to
indicate user what and where the problem is.

\subsection basic_lesson1_example_class Example class

Each lesson in the tutorial series has an example class, which has a very similar structure as following:
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Example

where Example::runProblem called by the main programme is as follows
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Run all

Note that every function starts and ends with error handling
\code
MoFEMFunctionBegin;
\\ function body
MoFEMFunctionReturn(0);
\endcode
That enables stacking functions calls in case of problems. We use functions stack to see what functions, on what lines have been called prior to the error.

\subsubsection basic_lesson1_example_setup Setup problem

Before calculation can be performed, some bookkeeping has to be done to manage complexities related to finite element problem. MoFEM does most of that boring job transparently, and only needs to be provided with initial information.

\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Set up problem

Note that function adds field, which is defined by name, space, approximation base, and rank. To approximate density, we choose space of integrable functions and its derivatives, use a recipe from \cite NME:NME847 to construct base functions, and rank of the base is one since density is a scalar field. The order of approximation is set to one, i.e. linear functions are used. 

\subsubsection basic_lesson1_example_common_data Common data structure 

The common data structure is used to exchange data between operators run by
finite elements. It is a convenient method that allows to group data evaluated
at integration points which are in element, or aggregate data from all elements to
be used later by other parts of the code. You will find common data in all
examples for the following lessons, and other parts of MoFEM implementations. 

Common data structure is defined as follows
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Common data

and instance is created by method
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Create common data

where memory for Example::CommonData is allocated and handled by <a
href="https://www.boost.org/doc/libs/1_61_0/libs/smart_ptr/shared_ptr.htm">shared
pointer</a>. Using <a
href="https://www.boost.org/doc/libs/1_64_0/libs/smart_ptr/enable_shared_from_this.html">enable_shared_from_this</a>
and function Example::CommonData::getRhoAtIntegrationPtsPtr shared pointer to
vector  \em rhoAtIntegrationPtsPtr can be obtained. Finally, PETSc vector is
created. Here we are using MoFEM::SmartPetscObj, which is a special smart
pointer for handling PETSc objects. 

Smart pointers, boost::shared_ptr and MoFEM::SmartPetscObj, are used to maintain the life of dynamically allocated objects. You can think about smart pointers as a regular pointer, and to understand the following code you do not have to know more about them. More explanation is needed for
\code

int local_size;
if(mField.get_comm_rank() == 0) // mField.get_comm_rank() gets procesor number
  // First processor
  local_size = CommonData::LAST_ELEMENT; // Last element is size of vector
else 
  // other processors
  local_size = 0; // local size of vector is zero on other processors

commonDataPtr->petscVec = createSmartVectorMPI(
  mField.get_comm(), local_size, CommonData::LAST_ELEMENT);
\endcode
this is a smart pointer to PETSc Vector, it is created by function
MoFEM::createSmartVectorMPI which calls PETSc function VecCreateMPI, described
<a
href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecCreateMPI.html">here</a>. PETSc vector enables access vector from multiple processes and is used in parallel computing. Function needs to be provided with commentator, hereby \em mField.get_comm(), which is a communicator of MoFEM. Communicator holds a group of processes that can communicate with each other. Next local size of the vector is provided, here it is equal to 10, since we store mass, three first moments, and six second moments of inertia, in the order as it is in Example::CommonData::VecElements. Local size of the vector is ten, which is equal to Example::CommonData::VecElements on the first processor, and zero on other processors. It means that all data will be accumulated on processor 0 as shown in \ref basic_l1_figure_6 "Figure 6". The global size of the vector is a sum of all local size, and thus is ten,
i.e. CommonData::VecElements.

In all the following lessons, including this one, we implemented code to make it
work with distributed meshes. 

\anchor basic_l1_figure_6
\image html basic_lesson1_partitioning.png "Figure 6: Mesh partitioning" width=800px

\subsubsection basic_lesson1_bc Setting density field

\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Set initial density

For simplicity, density is set to unity, at each mesh node. That creates a uniform density field. However, applying easy modification, arbitrary density field can be set. Function \em set_density argument has coordinates, so you can set any density distribution you like. Core function MoFEM::FieldBlas::setVertexDofs is doing hard work to set the values to the mesh nodes by iterating each node, getting its coordinates and calling function provided by the user, i.e. \em set_density.

\subsubsection basic_lesson1_operators Operators and pipelines

To make calculations in MoFEM, you can use the \em Basic interface. You need to provide code with operators which are executed on finite element entities on the mesh. Operators can do various tasks, for example, evaluate field values at integration points, e.g. calculating \f$\rho_g^h\f$. You will use operators as well to compute integrals when you calculate volume, the first moment of inertia, or second moment of inertia. In other examples, operators are used for calculating differential operators, like gradient, divergence, etc., or assemble internal force vector. 

You do not have to write code which integrates explicitly over finite element entities on the mesh, MoFEM will do that for you once you provide sequences of operators to use. There is a reason for that since we aim to write code for finite elements which is generic and can be used in different contexts. For example, while the linear solver is used, or Newton iterations have to be done, or implicit/explicit time solver. Each solver does the tasks, integrate finite elements in a different order, thus solve iterates over the element. Solver only has to be provided with problem specific set of operators; however, the implementation of operators is independent on the type of solver. 

The developer provides MoFEM with operators which are executed on each element.
In particular, those operators are executed on each sub-entity of the element,
for example, finite triangle element is made from entities of nodes, three edges
and triangle itself. Operators are executed for each entity of finite element.
In this lesson, since density field is exclusively defined on nodes, operators
are run for nodes only. However, this is a special case.

On each finite element, several operators can be run in sequence. In principle, operators are used to break down a complex problem in simpler tasks. Each operator is implemented such that it iterates over integration points on the element. User operators are derived from a base class `UserDataOperator` and have by default several basic functions which  vary for different element shapes. However, they always provide integration points, shape functions at integrations points, finite element measure (length, area, or volume). 

Writing operator for your problem, you do not have to think about what type of
entity element is. The implementation is independent on element shape, approximation
order, and other fields used on the element, if there are any. 

Shape functions on each finite element can be different, depending on what approximation spaces you choose to use. Also, shape functions will depend on base and approximation order. Similarly, the number of DOFs and DOFs values on element entities depend on the field type. In this lesson, in function Example::setUP we have defined density field as
\code 
CHKERR simple->addDomainField("rho", H1, AINSWORTH_LEGENDRE_BASE, 1);
CHKERR simple->setFieldOrder("rho", 1);
\endcode
\em H1 means that standard-conforming elements are used, and approximation order
is one. Conforming element have approximation function that is continuous along
element edges and at the node. Mathematically speaking, function in \em H1 is piecewise continuous,
i.e. it is integrable and gradients of the
function are also integrable. Integrable means that when you calculate integral, it
gives finite value, other than \f$+/-\infty\f$, i.e. the result is a real
number. 
Approximation order 1 means that is linear piecewise continuous. To build
approximation base, we are using recipe AINSWORTH_LEGENDRE_BASE, which is
described in details here \cite ainsworth2001essential. However, since we use
the first order, shape functions are  no different  as presented in \ref
basic_l1_figure_3 "Figure 3".

Our main task in this lesson is to calculate the mass, the first moment of inertia
and the second moment of inertia. In order to do that, on each element, we have
to calculate density at integration points, then calculate moments of inertia. That is
depicted on \ref basic_l1_figure_7 "Figure 7 " by user data operators (UDOs)
shown by four green boxes. \ref basic_l1_figure_7 "Figure 7" also depicts the
flow of data between operators, through \em Example::CommonData structure. 

\anchor basic_l1_figure_7
\image html basic_lesson1_ops.png "Figure 7: Operators and common data" width=800px 

On each element, first operator MoFEM::OpCalculateScalarFieldValues is used to calculate values at integration points, in Example::CommonData::rhoAtIntegrationPts. Then in operators Example::OpZero, Example::OpFirst, and Example::OpSecond, the vector which has a size equal to the number of integration points on the element is used to evaluate moments. Moments from each element are assembled to Example::CommonData::petscVec. Once all elements are evaluated, vector Example::CommonData::petscVec results are printed at the end of the programme. 

Operators have to be pushed into pipelines through MoFEM::Basic interface.  MoFEM::Basic has several streams of pipelines, to evaluate matrices and vectors, and which are executed on domain and boundary (skin) elements. Here we integrate vector iterating domain element, see \ref basic_l1_figure_7 "Figure 7", red box on the left. Operators are pushed to the pipeline by executing the following code
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Push operators to pipeline
In the snippet above, you can see four operators pushed in sequence, like in \ref
basic_l1_figure_7 "Figure 7". Operators are pushed to \em
basic->getOpDomainRhsPipeline(), that is a sequence to calculate vectors on
domain finite elements. We call it sequence since operators are executed on
finite elements in the order that they are pushed.

To set integration points at which base functions are evaluated, the user needs to specify integration rule, that is done by the following code
\code
auto integration_rule = [](int, int, int p_data) { return p_data + 2; };
CHKERR basic->setDomainRhsIntegrationRule(integration_rule);
\endcode
Function \em integration_rule calculate rule by taking approximation order and adding two. Since under the second moment, the integral function is polynomial of order \f$p+2\f$, where p is the order of the polynomial used to approximate density, and two emerge from term \f$x^ix^j\f$. This is the highest polynomials evaluated out of three operators. Integration rule set as above enables to calculate three moments of inertia exactly, and the only errors come from geometry approximation and approximation of density by piecewise polynomial.

Since we use piecewise linear polynomial to approximate density, i.e. \f$p=1\f$, and thus highest order polynomial is for the second moment of inertia and is three, so integration rule set by the code will be three. Note setting integration rule to a higher value would increase the number of integration points, and that will not change results. Although, setting higher integration rule that is needed makes code slower since functions have to be evaluated in more points, and CPU has to do more operations. 

Calculations are triggered in function
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Integrate

in particular by MoFEM::Basic::loopFiniteElements. At that point created sequence, implementation of operators, and evaluation are triggered. This is when all is happening, the rest of the code is declaration and definition of the problem. The snippet above shows as well that vector of moments, i.e. Example::CommonData::petscVec, is zeroed, next after integration over all elements are assembled.

Operator Example::OpSecond second is defined as follows
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Operator
Operators are derived classes, where essential part is overloaded function Example::OpSecond::doWork, which is called by MoFEM::Basic::loopFiniteElements on each element and integration takes place.

Finally we can look at function Example::OpSecond::doWork
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp SecondOp

We choose that operator since it is the most complex one among all three operators. We will dissect that code to understand it better.  We start by getting a number of integration points, which depend on the previously set integration rule. In the following lines, three tensors are declared, i.e. tensor (scalar) is set to weights and densities, and tensor of rank one (vector) is set to coordinates. Those three tensors point to values at the first integration point.  

Next, we create an array to store local values of the second moment of inertia. The second order of inertia is a symmetric tensor of rank two, which in three dimensions has six independent components. The array is continuous in the memory; it takes the shape of the tensor when the following code is run
\code
FTensor::Tensor2_symmetric<FTensor::PackPtr<double *, 0>, 3> t_I(
  &element_local_value[0], &element_local_value[1], &element_local_value[2],
  &element_local_value[3], &element_local_value[4],
  &element_local_value[5]);
\endcode

With all above at hand finally loop over integration points is made, and all function is evaluated, and aggregated in second order tensor. Note following code in the loop
\code
++t_w;
++t_rho;
++t_x;
\endcode

After looping over integration points is made, local element vector \em t_I is
assembled into a global vector Example::CommonData::petscVec. Note that vector
Example::CommonData::petscVec store all moments of inertia, first index stores
the zero moment, i.e. volume, next three indices store the first moment, and
last six indices store the second moment. For better clarity, indices are
enumerated by Example::CommonData::VecElements.

\note At this point, you might feel that you are overwhelmed with information.
This is natural, try to play with the code, make changes, or to debug it. Do not
try to understand all at once, start with the thing you can understand and
control. Each of the current MoFEM contributors and developers was at the stage
where you are now.

\subsection basic_lesson1_checking Checking code validity

Code is tested every time is code is changed and committed into the repository. The user with the command can trigger code testing
\code
ctest -VV
\endcode

In particular cmake function testing code executing function
\code
./basic_moment_of_inertia -file_name cube.h5m -test
\endcode
and code is validated in function Example::checkResults.

In function Example::checkResults test is run for a well-known solution for mesh in \em cube.h5m. Test like that verifies if volume, first moment and the second moment are calculated correctly. Function testing code is as follows
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Test example

You can see that line code
\code
CHKERR PetscOptionsGetBool(PETSC_NULL, "", "-test", &test, PETSC_NULL);
\endcode
checks if the test option is set in the command line. Code in brackets verifies if prescribed values are equal to calculated values. For example 
\code
for (auto i : {CommonData::SECOND_XX, CommonData::SECOND_YY,
                   CommonData::SECOND_ZZ}) {
      if (std::abs(array[i] - expected_second_moment) > eps)
        SETERRQ2(PETSC_COMM_SELF, MOFEM_ATOM_TEST_INVALID,
                 "Wrong second moment %6.4e !+ %6.4e", expected_second_moment,
                 array[i]);
    }
\endcode
iterates over diagonal values, and if the calculated value is not equal to expected value program throws an error using PTESc function  <a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/SETERRQ2.html">SETERRQ2</a>. The test is written for cube volume, of size one by one and coordinate system in the centre of the cube. Zero moments, i.e. volume, should be one. First moments should be zero since the cube centre is coordinate at the origin. Diagonal values of the second-order moment should be \f$1/12\f$, and off-diagonal terms of second-order should be zero since the axis of the cube aligns with the axis of the coordinate system. 

Writing a code test is essential. MoFEM is a complex system with several contributors, which most of them focused attention on the part of the code. Running tests like this one, contributors know that they not broken anything. That makes code development sustainable. 

Also, writing tests makes writing code faster and simpler, since once you write the code, it needs refactoring and improvements. The test will reassure you that optimisations and changes do not break working code.

Moreover, once your commits are submitted to the repository, MoFEM Jenkins server will the test independently, validating if your code is running not other system and computers. Results of that test are available here <http://cdash.eng.gla.ac.uk/cdash/index.php>.

\section Debugging 

Debugging is a method used to find errors or to understand what code does. A debugger is a program for debugging, which enables the user to execute code line by line and observe, or break (stop) code at desired lines of the source code. 
When you work in Linux, you can use GDB to debug code. If you work on macOS, you will instead you will use LLDB debugger.

Code has to be compiled with debugging flags, and when you installed MoFEM using
<a href="http://mofem.eng.gla.ac.uk/mofem/html/install_spack.html#installation_scripts">script for developer</a>, code with debugging flags is available in \em 
$HOME/mofem_install/um/build_debug/basic_finite_elements/basic.

VS Code has built-in functionality to debug code, both on Linux and macOS, for
details on how to use it, see
<https://code.visualstudio.com/docs/editor/debugging>. Here is an example of the
launch (in VS Code) configuration for LLDB and example from this lesson
\code
    {
      "type": "lldb",
      "request": "launch",
      "name": "basic_moment_of_inertia",
      "program": "basic_moment_of_inertia",
      "args": [
        "-file_name", "cube.h5m"
      ],
      "cwd": "$HOME/mofem_install/um/build_debug/basic_finite_elements/basic"  
    }
\endcode

\section basci_lesson1_code Code

The full source code is available here \ref basic/basic_moment_of_inertia.cpp .

*/
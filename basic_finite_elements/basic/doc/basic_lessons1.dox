/*! \page basic_lessons1 Integration on finite  element mesh

\section basic_lessons1_itro Introduction

Basic lessons intended to give new MoFEM developer, that is You, freedom to implement bespoke finite element codes. In this and following tutorials we assume that the you can programme, and is at least have basic fluency in C++ programming. Also, we assume that the you are engineer or physicist, or mathematician, someone which is interested in solving Partial Differential Equations (PDEs) using finite elements. Finally, we try to keep mathematical abstraction as basic as it can be. 

If you will be reading these lessons, and you do not understand tutorial; it is very likely ower fault not expressing ideas clear enough. If that is the case, please ask equations on our <a href="https://groups.google.com/forum/#!forum/mofem-group">Q&A</a> forum, or join us on <a href="https://mofem.slack.com/">Slack</a>. Your comments will enable us to improve this work, and if you are keen to contribute, starting from improving tutorials is the best way. 

All presented problems, except first, are for 2D problems. However,  all examples are implemented in such a way that can be extended to 3D. Once you get understanding, as an exercise, you can implement the 3D case.

\tableofcontents

In the following lessons, we intend to create consistently series of problems, which will give you the freedom to solve a large class of nonlinear problems.  

MoFEM provides interfaces with varying level of abstraction, lower abstraction, harder to use, demanding more knowledge about how MoFEM works and designs. Higher abstraction, limits flexibility, but makes implementation faster and simpler. Here we use \em Simple and \em Basic interfaces, which are complementary to each other.

The \em Simple interface is used to add approximation fields and delivers Discrete Manager (DM) to create matrices. Is \em Simple interface, since it assumes that fields and finite elements are set on the whole domain or whole boundary of the mesh. It assumes that problem has fix dimension, and not allows for mixing shells, beams and solid elements. From the other hand,  the \em Simple interface allows for multiple fields, integration on the domain, boundary and skeleton.  It also permits heterogeneous mesh, e.g. meshes with triangles and quads, and heterogenous approximation order. Despite some restrictions, \em Simple interface enables to fast implementation of a large class of problems.

The \em Basic interface is used to simplified creation of operator pipelines. The pipeline is a sequence of operations which one has to be run to assemble the right-hand vector or stiffness matrix.  <em>User data operator</em>  (UDO) is, for example, a differential operator which takes gradient of the field, or calculate strain, or use previously calculated strain in the pipeline to calculate stress, and in the end, calculate vector on the right-hand side.  In other words, the pipeline is a methode, to bereak complex problem into simple tasks, i.e. user data operators, for short UDOs.

It might not be apparent for you why we have \em Simple interface and \em Basic interface. \em Simple interface managed DOFs, i.e. approximation fields on the mesh manage entities on which finite elements are set and problems composed from finite elements.  However, do not provide a mechanism on how you assemble the vector of internal force, tangent matrix, or integrate. The tools for later are provided in \em Basic interface.  

\section basic_lessons1_start Essentials

\subsection basic_lessons1_siplexes Integration of simplexes 

Numrical inegration of function \f$\rho\f$, is given by formula,
\f[
\begin{align}
  I(\rho) = \int_\Omega \rho \textrm{d}V \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} W_g \| \mathbf{J}_g \| \rho^h_g
\end{align}
\f]
where \f$W_g\f$ is integration weight, \f$J_g\f$ is determinant of Jacobian, and \f$\rho^h_g\f$ is integrated function, e.g. density. Typically sum of the integration weights is scaled by volume (measure) of reference element, such that is weights equal to unity, as follows
\f[
\begin{align}
  \sum_{g=0}^{G-1} W_g  = 1 
\end{align}
\f]

Consequently, for such scaling for Jacobinan we use:

- For tetrahedron 
\f[
\begin{align}
  I(\rho^h) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} (W_g v) \rho^h_g
\end{align}
\f]
where \f$v\f$ is volume of refrence tetrahedon. 

- For triangle
\f[
\begin{align}
  I(\rho^h) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} (W_g a)  \rho^h_g
\end{align}
\f]
where \f$a\f$ is area of refrence trianlgle.

- For edge
\f[
\begin{align}
  I(\rho^h) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} (W_g l) \rho^h_g
\end{align}
\f]
where \f$l\f$ is length.

\subsection basic_lesson1_moments Moments of inertia

The distribution of mass in the body can be characterised by inertia moments, with respect to some origin and coordinate system. Moments have practical applications, are used for analysis motion of rigid bodies, or to characterise crosssection are in structural analysis. 

Moments are tensors, which zero moments have one scalar coefficient, first moments are 1d arrays, i.e. vectors, and second moments are second-order tensors, which coefficients for convenience can be organised in 2d table, i.e. matrix. This coefficient of moments depend on the observer, i.e. coordinate system, but is a strict rule, i.e. tensorial transformation rule, how coefficients of moments change with the observer.   For zero moments, area, all is simple, the volume of an object can not be changed by looking at it from the different point and angle, so it the same in every coordinate system.

- Zero inertia moment is a body mass, 
\f[
\begin{align}
M := \int_\Omega \rho(\mathbf{x}) \textrm{d}V
\end{align}
\f]
where \f$\rho\f$ is the material density, and \f$\Omega\f$ is a body domain. Mass characterise how much force needs to be applied for desired body acceleration, as stated Newton law
\f[
\begin{align}
a^i = M f^i
\end{align}
\f]
where \f$f^i\f$ is force, and kinematic energy can be expressed as 
\f[
\begin{align}
E_k = \frac{v^i M v^i}{2}
\end{align}
\f]

- First inertia moment, is given by
\f[
\begin{align}
S^i := \int_\Omega \rho(\mathbf{x}) x^i \textrm{d}V
\end{align}
\f]
where \f$x^i\f$ is coordinate in \f$i\f$ direction. Center of gravity of the body can be calculated a
\f[
\begin{align}
x_c^i = \frac{S^i}{M}.
\end{align}
\f]
where \f$\mathbf{x}_c\f$ is gravity centre of the body, or system of the bodies, note at centre of gravity first moment of inertia is zero.

- Second inertia moment is defined as
\f[
\begin{align}
I^{ij} := \int_\Omega \rho(\mathbf{x}) \left(x^ix^j\right) \textrm{d}V
\end{align}
\f]
where \f$(x^ix^j)\f$ is outer product, see <a href="https://en.wikipedia.org/wiki/Outer_product">here</a>. The second moment of inertia, analogously to mass, characterise how much torque has to be applied at body origin for desired body acceleration, as follow
\f[
\begin{align}
\omega^i = I^{ij} \tau^j = I^{ij} (\varepsilon^{jmn} x^m f^n)
\end{align}
\f]
and kinematic energy is 
\f[
\begin{align}
E_k = \frac{\omega^i I^{ij} \omega^j}{2}
\end{align}
\f]

\section basic_lessons1_theory Theory 

This section is not essential, you can skip it and come back to it later for deepr understanding of the problem, move to implememtation.

\subsection basic_lessons1_elements Integral over elements

The narrow interpretation of what finite element method is is that is a method for integration of functions on complex shapes. The integration domain is divided into the elements with primitive shapes, e.g. edge, triangle, quad,  tetrahedron, or hex, and on each element, integration rule on primitive shape is evaluated. Thus the complex problem is broken on man simple elements, on which over and over, the same simple procedure is evaluated - that makes it a perfect method for the computer.

The integral of function \f$\rho(\mathbf{x})\f$, where is coordinate \f$\mathbf{x}\in V\f$ is sum of integrals over all primitives shapes (elements) constituting whole integral domain 
\f[
\begin{align}
  I(\rho) = \int_V \rho(\mathbf{x}) \textrm{d}V \approx \int_{V^h} f(\mathbf{x}^h) \textrm{d}V = \sum_{e=0}^{N-1} \int_{\mathcal{T}^e} \rho(\mathbf{x}^h) \textrm{d}V = \sum_{e=0}^{N-1} I_\mathcal{T}
\end{align}
\f]
You may note that in the above equation value of integral is approximated since the domain of integration is not exact, and represented by mesh. Mesh is assembled from nonoverlapping elements, see mesh on the left \ref basic_l1_figure_1 "Figure 1". Making closer look at \ref basic_l1_figure_1 "Figure 1", you can see that geometry is complex, and contains patches from the sphere and some edges are circles. Those are not precisely circles, and not exactly part of the surface of the sphere since volume and its skin are represented by tetrahedrons and triangles respectively. Those elements have a straight edge, so is some difference between the mathematical model and its finite element discretisation. However, it is good news that error, i.e. difference between the mathematical model and discretisation can be controlled. You can refine mesh until error becomes small enough, as small as you need. From the other, if the surfaces of the body are flat surface, and edges are straight, the volume is approximated exactly. One can also generalise, and describe edges of elements by polynomials of second and higher-orders, that also enables control of geometry error. However, in this tutorial, we restrict ourself, and geometry will be represented by linear <em>Shape Functions</em>. For the rest of the tutorials, we will be using \f$(\cdot)^h\f$, to indicate that given quantity is approximated, and thus is some error associated with approximation.

\anchor basic_l1_figure_1
\image html basic_shape_function.png "Figure 1: Finite element mesh shape funstions, and integration points" width=800px

\subsubsection basic_lessons1_rule Integration in the element

Integration on each element, applying integration formulae, is as follows
\f[
\begin{align}
  I_\mathcal{T} = 
  \int_{\mathcal{T}^e} \rho(\mathbf{x}) \textrm{d}V \approx
  \sum_{g=0}^{G-1} W_g \rho\left(\mathbf{x}^h(\pmb\xi_g)\right) \| \mathbf{J}_g \| =
  \sum_{g=0}^{G-1} W_g \rho^h_g \| \mathbf{J}_g \| =
  \sum_{g=0}^{G-1} w_g \rho^h_g
\end{align}
\f]
where \f$\rho_g\f$ is value of integrated function at integrated point \f$\pmb\xi_g\f$ and \f$w_g=\| \mathbf{J}_g \| W_g\f$ is integration weight. You can see, that integral is expressed simply as sum of function valaules at integration multiplied by weights, something which can be easly implemented as a computer program. For given <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature">Gauss quadrature</a>  polynomials can be calculated exactly up to order of integration rule \f$r\f$, without any numerical error. So only error of integration comes from the fact that integrated function is approximated, i.e. \f$\rho_g \approx \rho_g^h\f$. If function is analaytical, order of error of\f$O(h^r)\f$, where \f$h\f$ is size of the element. We will dicuss how to choos integration rule on element in next lesson.

For integration on simplexes, i.e. (vertices), edges, triangles, tetrahedra, usually for convenience and efficiency, integration points are given by <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">barycentric coordinates</a> \f$\pmb\lambda\f$, see left of \ref basic_l1_figure_2 "Figure 2". For quadrilaterals, like quads and hex, quadrature points are constructed by the tensor product of integration rules in 1d, see right of \ref basic_l1_figure_2 "Figure 2". One can construct integration for other elements shapes, for prims by the tensor product of integration on triangle and line. For other shapes like for wedge, one can use Duffy transform. Duffy integration is constructed from hexahedron integration rule; then nodes are collapsed. Such procedure degenerate hexahedron, for example, to wedge. In other words, the reference element is hexahedron, but the physical element is a wedge. 

Finally,  in the end, we will use the integration rule from the shelf. However, at the moment, no matter what is the shape of a finite element, or how iteration points and weight are calculated. We have to remember the numerical integration will be the sum of integration weights multiplied by function values at integration points, and we are using that in this lesson.  Implementation of such integration is trivial, with the use of the single loop.

\anchor basic_l1_figure_2
\image html basic_shape_function_quad_and_tri.png "Figure 2: Shape functions on triangle and quadraliteral" width=800px

\subsubsection basic_lessons1_approx Approximation of density field

The  remian question is how to evaluate filed \f$\rho(\mathbf{x}^h_g)\f$ at integration points? In this case
\anchor lesson1_approx_rho
\f[
\begin{align}
  \rho_g = \rho(\mathbf{x}^h(\pmb\xi_g)) 
  \approx \rho^h_g = \sum_{m=0}^{M-1} \mathcal{N}_m(\pmb\xi_g) \overline{\rho}^m
\end{align}
\f]
where \f$\rho^h_g\f$ is interpolated value at integration point \f$\pmb\xi_g\f$, \f$\mathcal{N}_m\f$ is shape function at node \f$m\f$, \f$M\f$ is number of nodes on the elemment, see \ref basic_l1_figure_2 "Figure 2", and \f$\overline{\rho}_i\f$ value of funtion \f$\rho(\mathbf{x}_i)\f$ at node \f$i\f$ with coordinates \f$\mathbf{x}_i\f$. Note that finite  element interpolate function \f$\rho(\mathbf{x})\f$, since at nodes 
\f$\overline{\rho}_i = \rho(\mathbf{x}_i)\f$, and between nodes function is 
approximated. For linear shape functions, as in \ref basic_l1_figure_2 "Figure 2", approximation error is order of \f$O(h^2)\f$, where \f$h\f$ is size of element (mesh). By making mesh smaller, the error of approximation can be controled to achive desired accuracy. It another way to improve quality of approximation, and achive arbitrary error order, that is \f$O(h^{p+1})\f$. That 
can be acheived by using higher order polynomials to approximate function \f$\rho\f$, see for more details here \ref hierarchical_approximation_1.

\note A numerical method does not have to be exact, if it is that great, but is not the holy grail. We always aim to method be consistent, i.e. solution coverage to the exact solution, converge fast, and is robust, i.e. can solve real problems, not academic exercises. 

\subsubsection basic_lessons1_map Mapping reference and phiscal element

\anchor basic_l1_figure_3
\image html basic_map.png "Figure 3: Map reference element to physical element" width=700px

Looking closer on the \ref basic_l1_figure_1 "Figure 1", you can note that is a map between reference element (red triangle) and element in physical configuration (blue triangle). Map transform element, shift, rotate and stretch element (see \ref basic_l1_figure_3 "Figure 3"), and establish one to one relation (at least for all point without element boundary) between coordinates in reference element \f$\pmb\xi\f$ and physical coordinates \f$\mathbf{x}\f$ as follow
\anchor lesson1_map
\f[
\begin{align}
  x_i^h (\pmb\xi) = 
  \sum_{m=0}^{M-1} \mathcal{N}_m(\pmb\xi) \overline{x}^m_i 
\end{align}
\f]
Above equation is  not very diffrent from equation \ref lesson1_approx_rho "(16)", the only diffrence is that is evaluated for every coefficient  \f$i=0..d-1\f$, where  \f$d\f$ is dimension of the problem, e.g. for 3D promblem \f$d=3\f$. 

\subsubsection basic_lessons1_jacobian Jacobian

Note that integration over the physical element is problematic; it is much easier to construct integration rule on the reference element and integrate on it. To change the integration domain form physical element to the reference element, the concept of a map, the tangent map, and Jacobian, is useful, to change physical integration coordinates to reference coordinates. Calculation of integration rule for an element can be complex and time-consuming, however, if the rule on reference element is used, it can be precalculated and stored in the table to be used for all elements on the mesh.

From \ref basic_l1_figure_3 "Figure 3" we can see that infinitesimal local element can be mapped to element in physical space, that can be done by mapping infinitesimal vectors \f$d\pmb\xi_i\f$ into \f$d\mathbf{x}_i\f$, and it can be derived as follows. Expanding map at point \f$\mathbf{q}\f$ into Taylor series, we get
\anchor baic_taylor_expansion
\f[
  \begin{align}
  \mathbf{x}_\mathbf{q}^i = 
  \mathbf{x}_\mathbf{p}^i + d\mathbf{x}^i = 
  \mathbf{x}_\mathbf{p}^i + J^{ij}(\pmb\xi_\mathbf{P}) d\pmb\xi^j + O(\|d\pmb\xi\|^2)
  \end{align}
\f]
where Jacobian is
\f[
  \begin{align}
  J^{ij}(\pmb\xi_\mathbf{P})  = 
  \sum_{m=0}^{M-1} \left.
  \frac{\partial \mathcal{N}_m}{\partial \xi_j}
  \right|_\mathbf{P} \overline{\mathbf{x}}^m_i
  \end{align}
\f]
In eq. \ref baic_taylor_expansion "(18)", higher order term on the right can be ommited, since we focus attention on inifitisimal elements in reference element and phiscal element, that is  \f$dA\f$ and \f$da\f$, respectively. For example element \f$dA\f$ has size \f$\|d\pmb\xi\| \ll 1 \f$ and can be assumed that \f$\|d\pmb\xi\|^2 = 0\f$, without makeing any error. Note that once the higher-order terms are omitted, equation mapping domain in vicinity of point in reference element, into the domain in vicinity of the physical element is linear, and we called it a tangent map. Is the tangent map since it is accurate only for in vicinity point. Like a tangent plane pinned to the earth, glob can represent distances between locations only in small vicinity where is pinned. 

Using above derivation for Jacobian, in general, 3D case, i.e. tetrahedron, or hexahedron, infinitesimal element volume at integration point \f$g\f$ in physical configuration can be expressed as
\f[
\begin{align}
  dv = 
  \left| d\mathbf{x_2}^k (\varepsilon^{ijk} d\mathbf{x_0}^i d\mathbf{x_1}^j) \right| 
  =
  \left| \varepsilon^{ijk} J^{i0} J^{j1} J^{k2} \left(d\pmb\xi_0 d\pmb\xi_1  d\pmb\xi_2 \right) \right| 
  =
  \| \mathbf{J} \| dV
\end{align}
\f]
taking \f$d\pmb\xi_0\f$, \f$d\pmb\xi_1\f$, and \f$d\pmb\xi_2\f$, are cartesian base vectors and \f$\varepsilon\f$ is levi-civita rensor. \f$J^{i0}\f$, \f$J^{j1}\f$, and \f$J^{k2}\f$ are coulumns of Jacobian evalueted at integration point \f$\pmb\xi_g\f$. Connection between levi-civita tensor and Jacobian determinant can found <a href="https://en.wikipedia.org/wiki/Levi-Civita_symbol#Determinants">here</a>. Note that for lower dimenison above equation hold. Finally we have all necessery to calulate integral on finite element mesh
\f[
\begin{align}
  I(f) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} W_g \| \mathbf{J}_g \| \rho^h_g
\end{align}
\f]

\note You can learn more about inegtation from \cite zienkiewicz1977finite.

\note No one person invented the finite element method,  but in its roots in the invention of Shape Functions and isoparametric finite elements by <a href="https://en.wikipedia.org/wiki/Bruce_Irons_(engineer)">B. M. Irons</a> along with Ian C. Taig.

\section basic_lesson1_implementation Implementation

\subsection basic_lesson1_installations Installation

If you want to develop code in MoFEM, and you properly have if you are reading this tutorial, you have to install MoFEM for developer version, to do that follow instructions here \ref install_spack.

All files executable are located in, and there you will compile code.
\code
$HOME/mofem_install/build_debug/basic_finite_elements/basic
\endcode
whereas source code is located in 
\code
$HOME/mofem_install/mofem-cephas/mofem/users_modules/basic_finite_elements/basic
\endcode
This is called out of source compilation since code and programs are located in two different locations. It is a convenient way if you have different compilation options or linking different libraries, and you like to test all, against the same source code. Code in \em build_debug is compiled with debugging flags and is not optimised. Using the debugger you can run such code line by line, that can help you understand how it works, and find errors in your code. Information on how to debug code can be found
<a href="https://code.visualstudio.com/docs/introvideos/debugging">here</a>.

\note In default MoFEM installation you can create executables under another location, that  is
\code 
$HOME/mofem_install/build_opt/basic_finite_elements/basic
\endcode
Under \em build_opt location is optimised code, which is much faster, but harder to inspect with debugger. 

\subsection running_lesson_1 Running code

To run code
\code
cd $HOME/mofem_install/build_opt/basic_finite_elements/basic
./basic_moment_of_inertia -file_name cube.h5m
\endcode

Code output should be following
\code
MoFEM version 0.9.1 (MOAB 5.1.0 Petsc Release Version 3.11.3, Jun, 26, 2019 ) 
git commit id 9b6655832763d7fc44c80e01d36bae166a69ed80
add: name rho BitFieldId 1 bit number 1 space H1 approximation base AINSWORTH_LEGENDRE_BASE rank 1 meshset 12682136550675316764
add finite element: dFE
add problem: SimpleProblem
Build Field rho (rank 0)
nb added dofs (vertices) 64 (inactive 0)
nb added dofs 64 (number of inactive dofs 0)
Nb. dofs 64
Build Finite Elements dFE
id 00000000000000000000000000000001 name dFE f_id_row 00000000000000000000000000000001 f_id_col 00000000000000000000000000000001 BitFEId_data 00000000000000000000000000000001 Nb. FEs 162
Nb. entFEAdjacencies 2430
partition_problem: rank = 0 FEs row ghost dofs problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. local dof 64 nb global row dofs 64
partition_problem: rank = 0 FEs col ghost dofs problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. local dof 64 nb global col dofs 64
problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. elems 162 on proc 0
partition_ghost_row_dofs: rank = 0 FEs row ghost dofs problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. row ghost dof 0 Nb. local dof 64
partition_ghost_col_dofs: rank = 0 FEs col ghost dofs problem id 00000000000000000000000000000001 FiniteElement id 00000000000000000000000000000001 name SimpleProblem Nb. col ghost dof 0 Nb. local dof 64
Mass 1.0000e+00
First moment of inertia [ -4.3368e-19, -1.4095e-17, -1.3878e-17 ] 
Second moment of inertia [ 3.4961e-312, 1.0000e+00, 0.0000e+00; 6.9531e-310 8.3333e-02; -6.0715e-18 ]
\endcode

Code print at the beginning version of the MoFEM library.  I the same line versions of MOAB and PETSc are printed respectively. That will enable to reproduce errors if occurred and fix bugs. Next information is printed that element has been added, i.e. \em dFE, and field DOFs for density field, i.e. \em rho. Here only DOFs on vertices are added. Thus linear approximation of density is considered. After that information about a number of finite elements is printed, i.e. 162, and the problem itself, i.e. SimpleProblem, the number of DOFs on rows & columns, i.e. 64, and other information related to mesh partitioning. Most of that information is obsolete for this particular less. Finally, the results are printed.


\subsection basic_lesson1_programming Editor

You can use your favourite editor, vim, emacs, sublime, atom.io, if you have one, however, if you have no preferences we recommend <a href="https://code.visualstudio.com">vscode</a>. We have some tips on how you can configure it to make it work well with MoFEM, see \ref configure_vs_code.

\note We have some programming conventions, and style of programming, see \ref coding_practice. You do not have to jump and learn conventions, you will pick-up style on the way, how children pick-up cultural conventions when they grow up. In MoFEM we are using clang-format, to help us unify programming style. Most of the editors use clang-format. For example how to do that in vscode is described <a href="https://code.visualstudio.com/docs/cpp/cpp-ide">here</a>. Keeping the same style, and learning and following programming conventions is important in the long term. MoFEM is open community code, and if everyone follows the agreed style, it improves code readability, and people understand each other better. 

\subsection basci_lesson1_main Main function

The main function relatively short, and look the same for every program 
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp  main

You can use the above snipped to start your code. Main functions is responsible for kick-start the job, and it has stages;

- The main programme begins with registering MoFEM DM interface in PETSc data structures. That enables transparent control of MoFEN database by PETSc solvers, and vice-versa use PETSc standard interface to create matrices, vectors, and other PETSc objects

- Next, MOAB database is created and connected to the interface. A similar approach is made for MoFEM database. MoAB database stores data about mesh, whereas MoFM database stores data about finite element method, approximation bases, finite elements and problems. MoFEM is another level on top of MOAB databse since finite element data are stored on data tags created on mesh entities. 

- Finally, problem-specific example class is created, and calculations are executed in Example::runProblem.

\subsection basci_lesson1_error_handling Error handling

Errors are catch in the end, see 
\code
try {

}
CATCH_ERRORS;
\endcode
That part of the code is responsible for handling all the error, initiated inside PETSc, MOAB, Boost, standard library, and MoFEM or developer functions. PETSc, MOAB, and MoFEM functions return error code, to handle them properly, do as follow
\code
  CHKERR PetscFunction();   // PETSc function
  CHKERR moab.function();   // MOAB function
  CHKERR m_field.funtion(); // MoFEM function
\endcode
Catching errors will make searching for runtime errors easier, and in case of the problem allow for seeking help, see \ref guidelines_bug_reporting.

\note When you programme, you can encounter two type of error, <em>compilation errors</em>, and <em>runtime errors</em>. <em>Compilation errors</em> most often a syntax error, prevent the compiler from making program, you see them when you run \em make programme. Runtime errors are because some bug in programme, segmentation-fault, overflow, bad algorithm or you run of computer resources, memory. Those errors need to be handled, to indicate user what is the problem, where it is.

\subsection basic_lesson1_example_class Exmaple class

Each lesson has an example class, which very similar structure, as follows 
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Example

where Example::runProblem called by the main programme is as follows
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Run all

Note that every function start and end with error handling
\code
MoFEMFunctionBegin;
\\ function body
MoFEMFunctionReturn(0);
\endcode
That enable to stack functions calls in case of problems. We use functions stack to see what functions, on what lines have been called prior to the error.

\subsubsection basic_lesson1_example_setup Setup problem

Before calculation can be performed, some bookkeeping has to be done to manage complexities related to finite element problem. MoFEM does most of that boring job transparently, only need to be provided with initial information.

\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Set up problem

Note that function adds field, which is defined by name, space, approximation base, and rank. To approximate density, we choose space of integrable functions and its derivatives, use recipe form \cite NME:NME847 to construct base functions, and rank of the base is one since density is a scalar field. The order of approximation is set to one, i.e. linear functions are used. 

\subsubsection basic_lesson1_example_common_data Common data struture 

The common data structure is used to exchange data between operators run by finite elements. It is a convenient method that allows to group data evaluated at integration points which in element, or aggregate data from all elements to be later used by other parts of the code. You will find common data in all examples for the following lessons, and other parts of MoFEM implementations. 

Common data structure is defined as follows
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Common data

and instance is created by method
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Create common data

where memory for Example::CommonData is allocted and handled by <a href="https://www.boost.org/doc/libs/1_61_0/libs/smart_ptr/shared_ptr.htm">shared pointer</a>. Using <a href="https://www.boost.org/doc/libs/1_64_0/libs/smart_ptr/enable_shared_from_this.html">enable_shared_from_this</a> and function Example::CommonData::getRhoAtIntegrationPtsPtr shared pointer to vector  rhoAtIntegrationPtsPtr can be obtained. Finally PETSc vector is created, we using here MoFEM::SmartPetscObj, which is special smart pointer for handling PETSc objects. 

Smart pointers, boost::shared_ptr and MoFEM::SmartPetscObj, are used to maintain the life of dynamically allocated objects. You can think about smart pointers as a regular pointer, and to an understanding following code you do not have to know more about them. More explanation is needed for
\code

int local_size;
if(mField.get_comm_rank() == 0) 
  // First processor
  local_size = CommonData::LAST_ELEMENT;
else 
  // other processors
  local_size = 0;

commonDataPtr->petscVec = createSmartVectorMPI(
  mField.get_comm(), local_size, CommonData::LAST_ELEMENT);
\endcode
this is smart pointer to PETSc Vector, it is created by function MoFEM::createSmartVectorMPI which calls PETSc function VecCreateMPI, described <a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecCreateMPI.html">here</a>. Function needs to be provided with commentator, hereby \em mField.get_comm(), which is a communicator of MoFEM. Communicator holds a group of processes that can communicate with each other. Next local size of the vector is provided, here is equal 10, since we store mass, three first moments, and six-second moments of inertia, in order as it is in CommonData::VecElements. Local size of the vector is ten, which is equal to CommonData::VecElements::VecElements on the first processor, and zero on other processors. It means that all data will be accumulated on processor one. The global size of the vector is a sum of all local size, and thus is ten, i.e. CommonData::VecElements::VecElements.

In all the following lessons, including this one, we implemented code to make it work distributed meshes. 

\anchor basic_l1_figure_4 
\image html basic_lesson1_partitioning.png "Figure 4: Mesh partitioning" width=800px

\subsubsection basic_lesson1_bc Setting density field

\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Set inital density

For simplicity, dentistry is set to unity, at each mesh node. That creates a uniform density field. However, applying easy modification, arbitrary density field can be set. Function \em set_density argument has coordinates, so you can set any distribution density which you like. Core function MoFEM::FieldBlas::setVertexDofs doing hard work, set the values to the mesh nodes,  by iterating each node, getting it coordinates and calling function provided by the user, i.e. \em set_density.

\subsubsection basic_lesson1_opertors Operators and pipelines

To make calculations in MoFEM, you can use \em Basic interface. You need to provide code with operators who are executed on finite element entities on the mesh. Operators can do various tasks, for example, evaluate field values at integration points, e.g. calculating \f$\rho_g^h\f$. You will use operators as well to compute integrals when you calculate volume, the first moment of inertia, or second moment of inertia. In other examples, operators are used to calculating differential operators, like gradient, divergence, etc., or assemble internal force vector. 

You do not have to write code which integrates explicitly over finite element entities on the mesh, MoFEM will do that for you once you provide sequences of operators to use. That is a reason for that since we aim to write code for finite elements which is generic and can be used in different contexts. For example, used while the linear solver is used, or Newton iterations have to be done, or implicit/explicit time solver. Each solver does the tasks, integrate finite elements in a different order, thus solve iterates over the element. It only has to be provided with problem specific set of operators. 

The developer provides MoFEM with operators who are executed on each element. In particular, those operators are executed on each subentity of the element, for example, finite triangle element is made from entities; nodes, three edges and triangle itself. Operators are executed for each entity of finite element. In this lesson, since density field is exclusively defined on nodes, operators are run for nodes only. However, that is a special case.

On each finite element, several operators can be run in sequence. In principle, operators are used to breaking down a complex problem on simpler tasks. Each operator is implemented such that it iterates over integration points on the element. Operators are derived classes and provide some basic functions,  vary for different element shapes, however always provide integration points, shape functions at integrations points, finite element measure (length, area, or volume). 

Shape functions on each finite element can differ, depending on what approximation spaces You choose to use. Also, shape functions will depend on base and approximation order. Similarly, the number of DOFs and DOFs values on element entities depend on the field type. In this lesson in function Example::setUP we have defined density filed as
\code 
CHKERR simple->addDomainField("rho", H1, AINSWORTH_LEGENDRE_BASE, 1);
CHKERR simple->setFieldOrder("rho", 1);
\endcode
\em H1 means that standard-conforming elements are used, and approximation order is one. Conforming element means that approximation function is continuous along element edges and at the node. \em H1 means that is piecewise continuous, mathematically speaking such funcion is inegrable and gradient of function are integrable. Integrable means that when you calculate integral, it has finite value, diffrent than \f$+/-\infty\f$, i.e. is some raal number. Approximation order 1, means that is linear piecewise continuous. To build approximation base, we are using recipe AINSWORTH_LEGENDRE_BASE, which is described in details here \cite ainsworth2001essential. However, since we use the first order, shape functions are  no different  as presented in \ref basic_l1_figure_2 "Figure 2".

Our main task in this lesson is to calculate volume, the first moment of inertia and the second moment of inertia. In order to do that, on each element, we have to calculate density integration points, then calculate moments. That is depicted on \ref basic_l1_figure_4 "Figure 4" by user data operators (UDOs) shown by four green boxes. \ref basic_l1_figure_4 "Figure 4" also depict the flow of data between operators, through \em Example::CommonData structure. 

On each element, first operator MoFEM::OpCalculateScalarFieldValues is used to calculate values at integration points, in Example::CommonData::rhoAtIntegrationPts. Then in operators Example::OpZero, Example::OpFirst, and Example::OpSecond, the vector which has a size equal to the number of integration points on the element is used to evaluate moments. Moments from each element are assembled to Example::CommonData::petscVec. Once all elements are evaluated, vector Example::CommonData::petscVec results which are printed at the end of the programme. 

Operators have to be pushed into pipelines through MoFEM::Basic interface.  MoFEM::Basic has several streams of pipelines, to evaluate matrices and vector, and which are executed on domain and boundary (skin) elements. Here we integrate vector iterating domain element, see \ref basic_l1_figure_4 "Figure 4", red box on the left. Operators are pushed to the pipeline by executing the following code
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Push operators to pipeline
In snipped above you can see four operators pushed in sequence, like in \ref basic_l1_figure_4 "Figure 4". Operators are pushed to basic->getOpDomainRhsPipeline(), that is a sequence to calculate vectors on domain finite elements. We call it sequence since operators are executed on finite elements in order which are pushed. 

To set integration points at which base functions are evluated, user need to specify inetgartion rule, that is done by following code
\code
auto integration_rule = [](int, int, int p_data) { return p_data + 2; };
CHKERR basic->setDomainRhsIntegrationRule(integration_rule);
\endcode
Function \em integration_rule calculate rule by taking approximation order and adding two. Since under the second moment, the integral function is polynomial of order \f$p+2\f$, where p is the order of the polynomial used to approximate density, and two emerge from term \f$x^ix^j\f$. This is the highest polynomials evaluated out of three operators. Integration rule set as above enables to calculate three moments of inertia exactly, and only error comes from geometry approximation and approximation of density by piecewise polynomial.

\anchor basic_l1_figure_4 
\image html basic_lesson1_ops.png "Figure 4: Operators and common data" width=800px 

Calculations are triggered in function
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Integrate

in particular by MoFEM::Basic::loopFiniteElements. At that point created sequence, implementation of operators, and evaluation is triggered. This is when all is happening, the rest of the code is declaration and definition of the problem. Snipped above as well show that vector of moments, i.e. Example::CommonData::petscVec, is zered, and after integration over all elemeents is assmebled.

Opreator Example::OpSecond second is defined as follows
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Operator
Operators are derived classes, where essential part is overloaded function Example::OpSecond::doWork, which is called by MoFEM::Basic::loopFiniteElements on each elemnt and integration takes place.

Finally we can look at function Example::OpSecond::doWork
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp SecondOp

We choose that operator since it is most complex from all three operators. We will dissect that code to understand it better.  We start by getting a number of integration points, which depend on the previously set integration rule. In the following lines, tensor (scalar) is set to weights and densities, and tensor of rank one (vector) is set to coordinates. Three tensors point to values at the first integration point.  

Next, we create an array to store local values of the second moment of inertia. The second order of inertia is a symmetric tensor of rank two, which in three dimensions has six independent components. The array is continuous in the memory, it takes the shape of the tensor when the following code is run
\code
FTensor::Tensor2_symmetric<FTensor::PackPtr<double *, 0>, 3> t_I(
  &element_local_value[0], &element_local_value[1], &element_local_value[2],
  &element_local_value[3], &element_local_value[4],
  &element_local_value[5]);
\endcode

With all above at hand finally loop over integration points is made, and all funcion is evaluated, and aggregated in second order tenensor. Note following code in the loop
\code
++t_w;
++t_rho;
++t_x;
\endcode

After looping over integration points is made, local element vector \em t_I is assembled into a global vector Example::CommonData::petscVec. Note that vector Example::CommonData::petscVec store all moments of inertia, on first index first moment, i.e. volume, on next three indices store the first moment, and on last six indices second moment. For better clarity, indices are enumerated by Example::CommonData::VecElements.

\note At this point, you might feel that you are overwhelmed with information. This is natural, try to play with the code, make changes, or to debug it. Do not try to understand all at once, start with the thing you can understand and control. Each of the current MoFEM contributors and developers was at the stage were are you now.

\subsection basic_lesson1_checking Checking code validity

In function Example::checkResults test is run for a well-known solution. Test like that verifies if volume, first moment and the second moment are calculated correctly. Writing of tests is essential, simplify writing and modification of the code. Enables code developed, and without test development of sustainable is impossible, You should always try to write a test for your code.  

See how code for first lsson is tested here
\snippet users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp Test example

\section Debugging 

Debugging is a way of searching for errors. The debugger is a program which each run source code lines step by step, under control of the user, and the allow to observe how the state of variables.  

Code has to be compiled with debugging flags, and when installing code for developers,  code is built in two versions, optimised fast version, and version with no optimisation with debugging flags for debugging and code development, 

Writing of the code is relatively quick, searching for bugs and errors is usually very time-consuming. When you work in Linux, you can use GDB to debug code. It is many examples and tutorials on how to debug code, for example, see <https://youtu.be/bWH-nL7v5F4>. If you work on OSX, you will instead you will use LLDB  debugger.

VSCode has built-in functionality to debug code, both on Linux and OSX, for details on how to use it, see <https://code.visualstudio.com/docs/editor/debugging>.

\section basci_lesson1_code Code

\include users_modules/basic_finite_elements/basic/basic_moment_of_inertia.cpp 

*/
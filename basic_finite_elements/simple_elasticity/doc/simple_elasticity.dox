/*! \page simple_elasticity_1 Solid elasticity

This tutorial's motivation is to show how finite element is implemented using
basic blocks, like the Lego block where one can combine them in arbitrarily,
restricted only by his or her imagination. That is not short and compact
code, where PDE can be in single line, but code which can be modified and
changed in a way that was not imagined by developers.

\section simple_elasticity_introduction Introduction

This tutorial presents in detail a number of basic Finite Element processes
implemented in MoFEM through a user module implementation that solves a
simple linear elastic problem. The aim of this presentation is to facilitate
new developers to familiarise themselves with certain practices and
formulations regarding finite element processes and mesh information
manipulation. Readers are encouraged to read \ref general_data_structure,
\ref hierarchical_approximation_1 and \ref hello_world_tut1 before starting
the present tutorial. Initially, generation of a mesh is presented and then
the module developed for this tutorial is dissected. Finally, code run and
post processing of the results are discussed.

\tableofcontents

\section simple_elasticity_problem The problem

The linear elastic problem modelled here is an orthogonal parallelepiped of
dimensions \f$1.0\times1.0\times4.0 \,\,\rm{m}\f$, subjected to a uniformly
distributed normal traction \f$\bar t\f$ on one face while its opposite face
being simply supported. The geometry of the problem is schematically
presented in \ref Figure_1_Elastic "Figure 1". Boundary conditions are
applied on the two faces with both edges equal to \f$1\,\,\rm m\f$. Vertical
displacements (along z direction) along the whole area of the bottom face are
restricted. To prevent rigid body motion, one of the bottom corners
displacements along the x and y direction are restricted by the supports
numbered 3 and 2 presented in \ref Figure_1_Elastic "Figure 1", respectively.
Finally, displacements along y direction is restricted at a different corner
of the bottom face by the support number 1 to prevent rigid body rotation.

\anchor Figure_1_Elastic
\image html Problem.png "Figure 1: Geometry of the problem under consideration: orthogonal parallelepiped with dimensions of 1 m along x and y axis and 4 m along z axis that is simply supported on the bottom face and uniformly distributed normal tractions along the upper face." width = 300px

The boundary conditions where chosen to allow the body to deform freely on
both horizontal directions. In this way, verification will be possible by
checking the match between Poisson ratio recovered by the analysis results
with the one used as input as a material parameter. Since only normal
tractions are applied on the top face, no bending will occur along the faces
parallel to the z axis and therefore no extra support is needed along the
bottom edge connecting support 1 and 2.

Particular features associated to mesh input to solve the problem described
here will be presented next.

\section simple_elasticity_mesh_input Mesh input

The user module presented here is associated with a specific mesh input.
Therefore, mesh generation process is briefly presented focusing only on the
steps that are closely linked to the module implementation. There is no
intention to provide detail guidelines for using the mesh generator. Mesh
generators that can be used to run analyses in MoFEM are Salome, GMsh and
Cubit. Mesh features presented here are identical to those found in all three
aforementioned software packages.

The mesh presented in \ref Figure_2_Elastic "Figure 2" corresponds to the
geometry of the problem illustrated in \ref Figure_1_Elastic "Figure 1".
However, it should be noted that the mesh generator as well as MoFEM do not
require a particular choice of units. Instead, the user is responsible to be
consisted with her/his own choice of units for any input parameter.

\anchor Figure_2_Elastic
\image html CubitMesh1_1.png "Figure 2: Mesh geometry of an orthogonal parallelepiped of dimensions of 1x1x4 along x, y and z axis, respectively." width = 600px


To prescribe the boundary conditions for the generated mesh presented in \ref
Figure_1_Elastic "Figure 1", a number of blocks must be added to the mesh. To
prescribe the restriction on the vertical displacements on the bottom face
and the normal traction on the upper face, surface blocks 1 and 3 are added
on the corresponding faces as presented in \ref Figure_3_Elastic "Figure 3"
and \ref Figure_4_Elastic "Figure 4", respectively. Moreover, to assign the
displacement restrictions represented by rollers 1, 2 and 3 in \ref
Figure_1_Elastic "Figure 1", vertex blocks have to be added as presented in
\ref Figure_5_Elastic "Figure 5" and \ref Figure_6_Elastic "Figure 6".

\anchor Figure_3_Elastic
\image html Block1_1.png "Figure 3: Face block added to the bottom face of the orthogonal parallelepiped that will be used to restrain vertical displacements along that face." width = 600px

\anchor Figure_4_Elastic
\image html Block3_1.png "Figure 4: Face block added to the top face of the orthogonal parallelepiped that will be used to apply uniformly distributed normal tractions along that face." width = 600px

\anchor Figure_5_Elastic
\image html Block2_1.png "Figure 5: Vertex block added to one of the corners of the bottom face of the orthogonal parallelepiped that will be used to prescribe the boundary conditions represented by the rollers 2 and 3 presented in Figure 1." width = 600px

\anchor Figure_6_Elastic
\image html Block4_1.png "Figure 6: Vertex block added to one of the corners of the bottom face of the orthogonal parallelepiped that will be used to prescribe the boundary conditions represented by the roller 1 presented in Figure 1." width = 600px

No specific boundary conditions are applied through the mesh generator. To
achieve prescription of boundary conditions, certain mesh regions have to be
numbered and characterised as ''Blocks''. As explained earlier, block feature
exists in Salome, GMsh and Cubit. Therefore, this feature is not restricted
to the particular choice of mesh generator. MoFEM user module executable will
read the mesh input file and apply boundary conditions (see Sections \ref
simple_elasticity_mesh_block and \ref ApplyDirichletBc). 
As an example, a simple journal script which can be used in Cubit to generate the mesh is found below
\verbatim
reset

# Geometry
brick x 1 y 1 z 4

# Mesh preparation and generation
volume 1 scheme tetmesh
volume 1 size auto factor 10
mesh volume 1

block 1 surface 2
block 2 vertex 7
block 3 surface 1
block 4 vertex 6

# Boundary condition
# The boundary condition for this problem is defined in the source code

# Save the model to *.cub file which will be used in MoFEM code
save as "Users/username/mofem_install/um/build/basic_finite_elements/simple_elasticity/cubit.cub" overwrite
\endverbatim


\section simple_elasticity_code_dissection Code dissection

\subsection simple_elasticity_header_files Header files

The header file included in the user module are presented below.
\code
#include <BasicFiniteElements.hpp>
\endcode

\subsection simple_elasticity_initialisation Initialisation

Initially, MoFEM and PETSc has to be initialised through the code line below

\code
  // Initialize MoFEM
 MoFEM::Core::Initialize(&argc, &argv, (char *)0, help);
\endcode

and now PETSc objects can now be declared. As discussed in \ref
general_data_structure article, PETSc objects are used to solve the large
computational problem of the system of linear equations.

To create the mesh database and an interface to interact with it, the
following piece of code is included
\code
  // Create MoFEM database and link it to MoAB
  moab::Core mb_instance;//create database
  moab::Interface &moab = mb_instance; //create interface to database  
\endcode

MoFEM database is created along with an interface object that will be used
as a mean to interact with MoAB database
\code
    MoFEM::Core core(moab); //MoFEM database
    MoFEM::Interface &m_field = core; //create interface to database
\endcode

This interaction is schematically presented as the interaction of level 1 and 2 in \ref Figure_7_Elastic "Figure 7" on the right hand
 side.

\anchor Figure_7_Elastic
\image html Interface.png "Figure 7: Database interaction using interface objects Discrete Manager, m_field and Simple interface." width = 600px

Moreover, the Discrete Manager that is the PETSc implementation within MoFEM
has to be register to PETSc (schematically presented as interaction of levels
1 and 2 on the left hand side in \ref Figure_7_Elastic "Figure 7")
\code
    CHKERR DMRegister_MoFEM("DMMOFEM");
\endcode

Interaction of levels 2 and 3 is going to be described in Section \ref
simple_elasticity_createFE.

To read data from the command line when executing the program the lines below
are introduced
\code
    // Get command line options
    int order = 3;                    // default approximation order
    PetscBool flg_test = PETSC_FALSE; // true check if error is numerical error
    CHKERR PetscOptionsBegin(PETSC_COMM_WORLD, "", "SimpleElasticProblem", "none");

    // Set approximation order
    CHKERR PetscOptionsInt("-order", "approximation order", "", order, &order, PETSC_NULL);

    // Set testing (used by CTest)
    CHKERR PetscOptionsBool("-test", "if true is ctest", "", flg_test, &flg_test, PETSC_NULL);

    CHKERR PetscOptionsEnd();

\endcode


\subsection simple_elasticity_createFE Accessing simple interface

A pointer to an object of type \e simple\_interface is declared.
\code
  Simple *simple_interface;
  CHKERR m_field.getInterface(simple_interface);
\endcode

The second line of code creates a link between \e simple\_interface and \e m\_field
interface (schematically presented in \ref Figure_7_Elastic "Figure 7" as the
interaction of levels 2 and 3 by the left hand side arrow).

Interface \e simple\_interface has a number of functions implemented that allows
the user to build and manipulate PETSc, MoAB core and MoFEM core databases.
For instance, using the code below the mesh file is loaded and information of
the mesh is passed to MoFEM database.
\code
  CHKERR simple_interface->getOptions();
  CHKERR simple_interface->loadFile();
\endcode

\subsection{Fields}

Fields of user's interest can be introduced to the MoFEM database through
\e simple\_interface object as presented below for the shape functions field in
our 3D domain.
\code
  CHKERR simple_interface->addDomainField("U", H1, AINSWORTH_LEGENDRE_BASE, 3);
  CHKERR simple_interface->setFieldOrder("U", order); // to approximate function
\endcode

By using \ref MoFEM::Simple::addDomainField function the name of the field
chosen by the user can be introduced (in this case the name chosen is U). The
space chosen to operate is H1 and the type of shape functions is chosen
through the key-word AINSWORTH\_LEGENDRE\_BASE are Legendre polynomials
proposed by Ainsworth and Coyle. Finally, the hard-coded number 3 determines
the dimensions of the degrees of freedom related to each shape functions.
Here, this number is 3 since it is a displacement field in a 3D space.
Should the unknown field be pressure, then the hard-coded number will be 1
instead of 3 since pressure always has one dimension. Furthermore, the order
of the approximation field is introduced through function MoFEM::Simple::setFieldOrder. As
explained earlier, the order of the approximated field can be chosen and the
appropriate Hierarchical shape functions will be taken into account
accordingly.

Other types of fields can also be introduced to MoFEM database. For instance,
an error field can be introduced to evaluate the error variance of the
solution throughout the domain. There will be explicit presentation of
introduction of other fields in next tutorials.

\subsection simple_elasticity_mesh_block Mesh block handling

\note MoFEM has functionality which allow to set boundary conditions directly in 
in mesh preprocessor, however here we focus on simple where boundary conditions are
handled in direct low level implementation.
 
The blocks numbered 1, 2, 3 and 4 (defined in Section \ref
simple_elasticity_mesh_input) will now be used to apply boundary conditions.
First, four Range objects (that are part of MoAB library) are declared for
each block
\code
Range fix_faces, pressure_faces, fix_nodes, fix_second_node;
\endcode

By using the MoFEM core interface m\_field, we loop through all meshSets in
our MoFEM m\_field through the macro
\_IT\_CUBITMESHSETS\_BY\_BCDATA\_TYPE\_FOR\_LOOP\_(m\_field, BLOCKSET, bit)
as
\code

    enum MyBcTypes {
      FIX_BRICK_FACES      = 1,
      FIX_NODES            = 2,
      BRICK_PRESSURE_FACES = 3,
      FIX_NODES_Y_DIR      = 4
    };


    for (_IT_CUBITMESHSETS_BY_BCDATA_TYPE_FOR_LOOP_(m_field, BLOCKSET, bit)) {
      EntityHandle meshset = bit->getMeshset();
      int id               = bit->getMeshsetId();

      if (id == FIX_BRICK_FACES) { // brick-faces

        CHKERR m_field.get_moab().get_entities_by_dimension(meshset, 2,
                                                            fix_faces, true);

        Range adj_ents;
        CHKERR m_field.get_moab().get_adjacencies(fix_faces, 0, false, adj_ents,
                                                  moab::Interface::UNION);

        CHKERR m_field.get_moab().get_adjacencies(fix_faces, 1, false, adj_ents,
                                                  moab::Interface::UNION);
        fix_faces.merge(adj_ents);
      } else if (id == FIX_NODES) { // node(s)

        CHKERR m_field.get_moab().get_entities_by_dimension(meshset, 0,
                                                            fix_nodes, true);

      } else if (id == BRICK_PRESSURE_FACES) { // brick pressure faces
        CHKERR m_field.get_moab().get_entities_by_dimension(
            meshset, 2, pressure_faces, true);

      } else if (id ==
                 FIX_NODES_Y_DIR) { // restrained second node in y direction
        CHKERR m_field.get_moab().get_entities_by_dimension(
            meshset, 0, fix_second_node, true);

      } else {
        SETERRQ(PETSC_COMM_WORLD, MOFEM_DATA_INCONSISTENCY, "Unknown blockset");
      }
    }
\endcode

the identity of each meshSet is found as 

\code
  EntityHandle meshset = bit->getMeshset();
  int id = bit->getMeshsetId();
\endcode

the \e id values correspond to the block numbering presented in Section \ref
simple_elasticity_mesh_input. When the value of id is equal to 1, 2, 3 or 4
boundary conditions are prescribed following the schematic in \ref Figure_1_Elastic "Figure 1".

For \e id equal to 1, the \e meshset is copied to object \e fix\_faces
through the MoAB function
\code
 CHKERR m_field.get_moab().get_entities_by_dimension(meshset, 2, fix_faces, true);
\endcode

were the hard coded number 2, refers to the dimension of entity under
consideration which in this case is a face. Numbers 0, 1 and 3 correspond to
vertices, edges and volumes, respectively.

Since we are interested in prescribing all degrees of freedom lying along the
faces, we need to copy all corresponding entities i.e. vertices and edges, to
the fix_faces object. This can be achieved by using the MoAB function
\e get\_adjacencies that provides information for the entities adjacent to the
input meshset (in this case \e fix\_faces). To implement this, another \e Range
object with name \e adj\_ents is created where all the information of the
adjacent entities are going to be copied as presented below.

\code
  Range adj_ents;
  CHKERR m_field.get_moab().get_adjacencies(fix_faces, 0, false, adj_ents, moab::Interface::UNION);
  CHKERR m_field.get_moab().get_adjacencies(fix_faces, 1, false, adj_ents, moab::Interface::UNION);
\endcode

Similar to the case of function \e get\_entities\_by\_dimension, hard coded
integers indicate the type of entities under consideration. Thereafter, all
information passed to the new \e Range object adj\_ents is copied to \e fix\_faces 
object through the MoAB function merge as
\code
fix_faces.merge(adj_ents);
\endcode

For the vertex type \e meshsets, no adjacencies are needed since only the
degrees of freedom associated to each block is going to be prescribed.
Therefore, invoking \e get\_entities\_by\_dimension function is sufficient.

For the case of the block of the upper face (\e id = 3), only the degrees of
freedom associated to the face are needed. Since the traction is uniform and
normal to the upper surface, it can be implemented as pressure and therefore
its implementation requires only degrees of freedom associated to the face as
presented in section ``Application of boundary conditions''.

Finally, the rest of blocks are of vertex type and there is no need to search
for adjacencies since only the degrees of freedom at those points are needed
to be prescribed.

\subsection{MoFEM Finite Element Method work flow}

All problems tackled by user modules proceed with the same workflow for
construction of the FEM solution. The workflow implemented in MoFEM is
schematically presented in \ref Figure_8_Elastic "Figure 8" and consists of
Definition,

Build and Assemble processes.
\anchor Figure_8_Elastic
\image html WorkFlow.png "Figure 8: MoFEM work flow." width = 200px

Definition process encompasses creation of stencils of finite elements,
fields and problems that are going to be used for the problem solution.
Field stencils include name, dimension and order and are defined as

\code
   CHKERR simple_interface->addDomainField("U", H1, AINSWORTH_LEGENDRE_BASE, 3);
   CHKERR simple_interface->setFieldOrder("U", order);
\endcode

For the elements, the stencil includes element's name, dimension, type of
fields that are going to be approximated in this element and the location of
the element that the fields operate (volume, boundary or skeleton). Each kind
of element used needs a different kind of stencil to be defined.

\code
    CHKERR simple_interface->defineFiniteElements();
\endcode

For reasons that will be apparent in Section \ref simple_elasticity_op_pressure, 
we will apply traction boundary conditions through a new element. Since this 
element is unknown to the simple interface
structure we need to explicitly define the element to be included in \e m\_field
\code
    // Add pressure element
    CHKERR m_field.add_finite_element("PRESSURE");
    CHKERR m_field.modify_finite_element_add_field_row("PRESSURE", "U");
    CHKERR m_field.modify_finite_element_add_field_col("PRESSURE", "U");   
    CHKERR m_field.modify_finite_element_add_field_data("PRESSURE", "U");
\endcode

Initially, the new finite element type with name is added to MoFEM core
database through the function \e add\_finite_element("PRESSURE"), where the
string "PRESSURE" used as input is the name that we chose to call the new
element. Then, the row and col field information of the "PRESSURE" element
are set to be those of "U" type. Furthermore, the list of fields that are
associated with "PRESSURE" element listed in the elements data is then set to
be only the "U" type field. In a more complicated case, more than one fields
can be added to the data, row and col structures of a finite element.
Similarly, definition of each problem stencil consists of problem's name and
the stencils of the various elements previously presented and are defined
using the code lines below

\code
    CHKERR simple_interface->defineProblem();
\endcode

Before defining a problem, all kinds of elements used have to be previously
defined.

\section simple_elastic_UDO_FE Introduction of user defined finite element

\subsection simple_elastic_DMM DMMoFEM

The new ``PRESSURE'' finite element has to be explicitly added to DMMoFEM
since it was not created through \e simple\_interface. Hence, a DM object is
declared and it is set to point to the DMMoFEM create by the interface as
\code
  DM dm;
  CHKERR simple_interface->getDM(&dm);
\endcode

and then the ``PRESSURE'' finite element is going to be added to DMMoFEM as

\code
  CHKERR DMMoFEMAddElement(dm, "PRESSURE");
\endcode

This is schematically illustrated as the interaction of levels 2 and 3 on the
left hand side of \ref Figure_7_Elastic "Figure 7". Then all information
introduced to DMMoFEM manager is partitioned

\code
  CHKERR DMMoFEMSetIsPartitioned(dm, PETSC_TRUE);
\endcode

This has to be explicitly defined in order to be able to solve the problem in
parallel computing where matrix assembly, linear system of equations and mesh
is distributed between processors.

\subsection simple_elastic_build Build

Then, fields and finite elements declared through \e simple\_interface are built
(second stage presented in \ref Figure_8_Elastic "Figure 8").

\code
    CHKERR simple_interface->buildFields();
    CHKERR simple_interface->buildFiniteElements();
\endcode

First, the dimension and order of fields according to the specific input
chosen is added to the field. In this case, the approximation field of
Hierarchic shape functions of Ainsworth and Coyle Legendre polynomials type
of order 3 and dimension 3 will be set to the field.

Thereafter, finite elements are built i.e. entities of the finite elements
are linked to the field components that were previously built and the order
of approximation is set to each entity.

\code
    CHKERR m_field.add_ents_to_finite_element_by_dim(0, simple_interface->getDim(), simple_interface->getDomainFEName(), true);
    CHKERR m_field.build_finite_elements(simple_interface->getDomainFEName());
\endcode

entities associated with the user defined ``PRESSURE'' finite element have to
be explicitly added to the finite element

\code
    CHKERR m_field.add_ents_to_finite_element_by_dim(pressure_faces, 2, "PRESSURE");
    CHKERR m_field.build_finite_elements("PRESSURE", &pressure_faces);
\endcode

Then to build all information regarding the element connectivities, and
fields associated to element entities into MoFEM core, the function below is
invoked.

\code
    CHKERR simple_interface->buildProblem();
\endcode

\subsection simple_elastic_fe_instances Finite element instances

MoFEM is designed such that approximation fields definition, FE element
declaration, FE element definition and FE implementation is explicitly
disentangled. That gives us great flexibility allowing for combining
individual parts of the code in a countless number of variations.

Implementation FE element can be done on range of levels of abstractions. Here
we present implementation which introduces the concept of \e User \e Defined
\e Operator. Using its implementation is not constrained to finite element
shape or approximation base of fields. In case of coupled or mix formulation,
it enables to break down complex code into smaller easy sub-tasks. Here we
only introduce basic concepts of this technology.

To create stiffness matrices and apply boundary conditions we will need to
finite element instance and attach \e User \e Defined \e Operators (UDOs).
For the stiffness matrix evaluation a new shared pointer \e elastic\_fe is
instantiated to build elastic finite element instance and a UDO is pushed to the
elastic finite elements

\code
    boost::shared_ptr<VolumeElementForcesAndSourcesCore> elastic_fe(new VolumeElementForcesAndSourcesCore(m_field));
    elastic_fe->getOpPtrVector().push_back(new OpK());
\endcode

schematically presented in \ref Figure_9_Elastic "Figure 9".

\anchor Figure_9_Elastic
\image html OperatorPush.png "Figure 9: Schematic representation inclusion process of User Defined Operators to finite element data structure." width = 600px


It is important to state that each instance of the structure of elastic finite
element pointed by shared pointed \e elastic\_fe carries with it the operator
OpK. Element can have sequence of operators, see for example \ref poisson_tut2.

To apply the traction boundary conditions, shared pointer \e pressure\_fe is
instantiated and then the operator OpPressure is attached to it to prescribe
the traction boundary conditions.

\code
    // push operators to elastic_fe
    boost::shared_ptr<FaceElementForcesAndSourcesCore> pressure_fe(new FaceElementForcesAndSourcesCore(m_field));
    pressure_fe->getOpPtrVector().push_back(new OpPressure());
\endcode

Finally, to prescribe the Dirichlet boundary conditions, the shared pointer
fix\_dofs\_fe is instantiated as a ApplyDirichletBc that is inherited from
MoFEM::FEMethod type (which lies within the class that are in the finite elements
family within MoFEM) as
\code
    boost::shared_ptr<FEMethod> fix_dofs_fe(new ApplyDirichletBc(fix_faces, fix_nodes, fix_second_node));
\endcode

The Ranges of \e fix\_faces, \e fix\_nodes and \e fix\_second\_node are given as input
to the constructor of ApplyDirichletBc to provide the mesh information
regarding the location of the degrees of freedom that will be prescribed.

Implementation of OpK, OpPressure and ApplyDirichletBc is presented in
Section \ref simple_elastic_UDO. A more general implementation for
application of boundary conditions will be presented in future tutorials.

\section simple_elastic_solve_problem Solving the problem

In this example the KSP solver provided by PETSc is used. Initially, finite
elements are pushed to the discrete manager and set KSP operators for
assembling the stiffness matrix.

\code
// Set operators for KSP solver
    ierr = DMMoFEMKSPSetComputeOperators(
        dm, simple_interface->getDomainFEName(), elastic_fe, nullFE, nullFE);
\endcode

Then, right hand side vector is evaluated and KSP operators are set to handle it. 

\code
    CHKERR DMMoFEMKSPSetComputeRHS(
        dm, "PRESSURE", pressure_fe, nullFE, nullFE);
\endcode

Thereafter, stiffness matrix \e A, vector of degrees of freedom
\e x and right hand side vector \e f are declared and
associated to the Discrete Manager DM

\code
   //initialise matrix A used as the global stiffness matrix
    Mat A;

    //initialise left hand side vector x and right hand side vector f
    Vec x, f; 

    //allocate memory handled by MoFEM discrete manager for matrix A
    CHKERR DMCreateMatrix(dm, &A);

    //allocate memory handled by MoFEM discrete manager for vector x
    CHKERR DMCreateGlobalVector(dm, &x);

    //allocate memory handled by MoFEM discrete manager for vector f of the same size as x
    CHKERR VecDuplicate(x, &f);
\endcode

Thereafter, members of finite elements instances are set to point to the
aforementioned objects
\code
    //precondition matrix A according to fix_dofs_fe  and elastic_fe finite elements
    elastic_fe->ksp_B  = A;
    fix_dofs_fe->ksp_B = A;

     //precondition the right hand side vector f according to fix_dofs_fe  and elastic_fe finite elements
    fix_dofs_fe->ksp_f = f;
    pressure_fe->ksp_f = f;
\endcode

Now all finite elements are prepared to be iterated (all operators have been
pushed to the elements and their members point to the structural problem A, f
and x objects) in order to Assembly the problem, i.e. the third part of the
work flow presented in \ref Figure_8_Elastic "Figure 8". Now, each element
created is iterated to compute and assemble the stiffness matrix and left hand
and right hand vectors as
\code
    CHKERR DMoFEMLoopFiniteElements(dm, simple_interface->getDomainFEName(), elastic_fe);
    CHKERR DMoFEMLoopFiniteElements(dm, "PRESSURE", pressure_fe);
\endcode

Furthermore, the part of the prescribed degrees of freedom are assembled in the left hand side vector through
\code
//This is done because only post processor is implemented in the ApplyDirichletBc struct
    CHKERR DMoFEMPostProcessFiniteElements(dm, fix_dofs_fe.get());
\endcode

Implementation of UDOs associated with \e pressure\_fe and \e fix\_dof\_fe are
going to be presented in Section \ref simple_elastic_UDO.

At this point matrix and two vectors have been assembled and we can now solve
our system of linear equations. Solver is declared first and then connected
to the MoFEM core as
\code
     //make available a KSP solver
    KSP solver;
    
    //make the solver available for parallel computing by determining its MPI communicator
    CHKERR KSPCreate(PETSC_COMM_WORLD, &solver);
\endcode

The solver object operators have to be prepared 
\code
    //making available running all options available for KSP solver in running command
    CHKERR KSPSetFromOptions(solver);

    //set A matrix to KSP solver and preconditioner
    CHKERR KSPSetOperators(solver, A, A);

    //set up the solver data structure for the iterative solver
    CHKERR KSPSetUp(solver);
\endcode
and finally the problem is solved
\code
    //solve the system of linear equations
    CHKERR KSPSolve(solver, f, x);
\endcode
the results are written in left hand side vector x
\code
    //make vector x available for parallel computations for visualization context
    VecView(x, PETSC_VIEWER_STDOUT_WORLD);
\endcode
and all values of degrees of freedom in x are mapped onto mesh entities
\code
    // save solution in vector x on mesh
    CHKERR DMoFEMMeshToGlobalVector(dm, x, INSERT_VALUES, SCATTER_REVERSE);
\endcode

\section simple_elastic_post_processing Post processing

To post process numerical results, initially a post processor object of type
PostProcVolumeOnRefinedMesh has to be created based on MoAB database
\code
    // Set up post-processor. It is some generic implementation of finite
    // element
    PostProcVolumeOnRefinedMesh post_proc(m_field);
    \endcode
\endcode
Thereafter, information of the problem solution is passed to the post processor as  
\code
    // Add operators to the elements, strating with some generic
    CHKERR post_proc.generateReferenceElementMesh();
    CHKERR post_proc.addFieldValuesPostProc("U");
    CHKERR post_proc.addFieldValuesGradientPostProc("U");
    CHKERR DMoFEMLoopFiniteElements(dm, simple_interface->getDomainFEName().c_str(), &post_proc);
\endcode
where initially a reference mesh is created is created, then field values are
added and finally all information related to finite elements such ass stain
and stresses are added into the post processor.

Finally, all information introduced to the post processor object is written
to an output file (in this case named out.h5m) as presented below
\code
    //write output
    CHKERR post_proc.writeFile("out.h5m");
\endcode


\section simple_elastic_clean_memory Clean memory

All dynamic memory objects A, x, f and DM that were created have to be
destroyed as presented below
\code
    //free memory handled by mofem discrete manager for A, x and f
    CHKERR MatDestroy(&A);
    CHKERR VecDestroy(&x);
    CHKERR VecDestroy(&f);

    //free memory allocated for mofem discrete manager
    CHKERR DMDestroy(&dm);
\endcode
to free the heap memory and prevent any memory leaks.
\section simple_elastic_UDO User Defined Operators (UDOs)

\subsection simple_elastic_element_stiffness Element stiffness matrix

In structural computational mechanics, the relationship to
evaluate the element stiffness matrix \f$\mathbf{K}\f$ is given by
\f[
{}^{(r,c)}_eK^{\alpha\beta}_{ik} = 
\int_{\Omega^e} 
\varphi_{,j}^\alpha 
D_{ijkl}  
\phi_{,k}^\beta
\, {d\Omega^e}
\label{eq:StiffnessIntegral}
\f]
where \f${\Omega^e}\f$ is the element volume, \f${\mathbf {D}}\f$ is the
elastic material stiffness tensor. The row base funcrions and column base
functions are represented by \f$\pmb\varphi^\alpha\f$ and
\f$\pmb\phi^\beta\f$, respectively. \f$\alpha=1,\dots,N^\textrm{row}\f$ and
\f$\beta= 1,\dots,N^\textrm{col}\f$ are indices of base function on row
entities and column entities, respectively. \f$N^\textrm{row}\f$ and
\f$N^\textrm{col}\f$ are numbers of base funcions on row entity and collumn
entity. The differentation is indicated
by subscript and index after the comma, as follows
\f[
\varphi^\alpha_{,j} :=  \frac{\partial \varphi^\alpha}{\partial x_j}.
\f]
where
\f[
  i,j = 0,1,2
\f]

The integration of the element stiffness matrix is broken down into blocks,
utilizing the construction of hierarchical approximation basis. For a
hierarchical approximation, base DOFs are grouped on vertices, edges, faces
and in the volume of the element, see for details to tutorial \ref
hello_world_tut1. In this tutorial matrix \f${}^{(r,c)}_e\mathbf{K}\f$ is
integrated by running over a combination of block, that is indicated by
superscripts \f$(r,c)\f$ on the left to the matrix \f$\mathbf{K}\f$, where
left-subscripts takes values
\f[
r,c := \{\textrm{ver, edge, face, vol} \}
\label{eq:setI}
\f]
The element matrix broked down on block subentities cab be represented as follows
\f[
{}_e\mathbf{K} =  
\left[
\begin{array}{cccc} 
 {}^{\textrm {ver ver}}\mathbf{K} & {}^{\textrm {ver edge}}\mathbf{K} & {}^{\textrm {ver face}}\mathbf{K} & {}^{\textrm {ver vol}}\mathbf{K}\\ 
 & {}^{\textrm {edge edge}}\mathbf{K} & {}^{\textrm {edge face}}\mathbf{K} & {}^{\textrm {edge vol}}\mathbf{K}\\ 
 && {}^{\textrm {face face}}\mathbf{K} & {}^{\textrm {face vol}}\mathbf{K}\\
 &&& {}^{\textrm {vol vol}}\mathbf{K}\\
 \end{array} 
\right]
\label{eq:StiffStiff}
\f]
Note that only symmetric part is calculated since the element stiffness matrix is symmetric.

\subsection simple_elasticity_OpK OpK

The operator called OpK is implemented as a class inheriting class
MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator
\code
struct OpK : public VolumeElementForcesAndSourcesCore::UserDataOperator {

};
\endcode

Struct's public members are 
\code
  // Finite element stiffness sub-matrix K
  MatrixDouble K;

  // Elastic stiffness tensor (4th rank tensor with minor and major symmetry)
  FTensor::Ddg<double, 3, 3> tD;

  //Young's modulus
  double yOung;
  //Poisson's ratio
  double pOisson;
\endcode

The first four lines encompass the declaration of matrices used for the
calculation of the elements stiffness matrix as presented in Section \ref simple_elastic_element_stiffness.

The next line variables are associated to the material stiffness tensor where
D is forth order tensor symmetric on two fisrt and two last indices, \e yOung
is the Young's modulus and \e pOisson is Poisson's ratio.
OpK constructor is implemented as follows
\code
 OpK(bool symm = true) : VolumeElementForcesAndSourcesCore::UserDataOperator("U", "U", OPROWCOL, symm)
  {

    // Evaluation of the elastic stiffness tensor, D, in the Voigt notation is
    // done in the constructor

    // hardcoded choice of elastic parameters
    pOisson = 0.1;
    yOung   = 10;

    // coefficient used in intermediate calculation
    const double coefficient = yOung / ((1 + pOisson) * (1 - 2 * pOisson));

    FTensor::Index<'i', 3> i;
    FTensor::Index<'j', 3> j;
    FTensor::Index<'k', 3> k;
    FTensor::Index<'l', 3> l;

    tD(i, j, k, l) = 0.;

    tD(0, 0, 0, 0) = 1 - pOisson;
    tD(1, 1, 1, 1) = 1 - pOisson;
    tD(2, 2, 2, 2) = 1 - pOisson;

    tD(0, 1, 0, 1) = 0.5 * (1 - 2 * pOisson);
    tD(0, 2, 0, 2) = 0.5 * (1 - 2 * pOisson);
    tD(1, 2, 1, 2) = 0.5 * (1 - 2 * pOisson);

    tD(0, 0, 1, 1) = pOisson;
    tD(1, 1, 0, 0) = pOisson;
    tD(0, 0, 2, 2) = pOisson;
    tD(2, 2, 0, 0) = pOisson;
    tD(1, 1, 2, 2) = pOisson;
    tD(2, 2, 1, 1) = pOisson;

    tD(i, j, k, l) *= coefficient;
  }
\endcode
where the material stiffness tensor for Hooke material is calculated.

When solving the problem, as presented in Section \ref simple_elastic_solve_problem, 
all finite elements are looped where this loop
invokes the OpK::doWork method of each operator of the finite element. The OpK::doWork
method of operator OpK is implemented as follows
\code
MoFEMErrorCode doWork(
      int row_side, int col_side,
      EntityType row_type, EntityType col_type,
      DataForcesAndSourcesCore::EntData &row_data, DataForcesAndSourcesCore::EntData &col_data)
  {
    MoFEMFunctionBeginHot;

    // get number of dofs on row
    nbRows = row_data.getIndices().size();
    // if no dofs on row, exit that work, nothing to do here
    if (!nbRows)
      MoFEMFunctionReturnHot(0);

    // get number of dofs on column
    nbCols = col_data.getIndices().size();
    // if no dofs on Columbia, exit nothing to do here
    if (!nbCols)
      MoFEMFunctionReturnHot(0);

    // K_ij matrix will have 3 times the number of degrees of freedom of the
    // i-th entity set (nbRows)
    // and 3 times the number of degrees of freedom of the j-th entity set
    // (nbCols)
    K.resize(nbRows, nbCols, false);
    K.clear();

    // get number of integration points
    nbIntegrationPts = getGaussPts().size2();
    // check if entity block is on matrix diagonal
    if (row_side == col_side && row_type == col_type) {
      isDiag = true;
    } else {
      isDiag = false;
    }

    // integrate local matrix for entity block
    CHKERR iNtegrate(row_data, col_data);

    // assemble local matrix
    CHKERR aSsemble(row_data, col_data);
    
    MoFEMFunctionReturnHot(0);
  }
\endcode

The element's column and row data structures as described in ``Hierarchic
approximation'' tutorial are passed to this function as \e col\_type and
\e row\_type respectively.

The number of degrees of freedom associated to each structure (which are
equal to the length of the column and row) is then passed to variables \e nbCols
and \e nbRows and checked that they are non-zero
\code
    // get number of dofs on row
    nbRows = row_data.getIndices().size();
    // if no dofs on row, exit that work, nothing to do here
    if (!nbRows)
      MoFEMFunctionReturnHot(0);
    // get number of dofs on column
    nbCols = col_data.getIndices().size();
    // if no dofs on columns, exit nothing to do here
    if (!nbCols)
      MoFEMFunctionReturnHot(0);
\endcode
after the element's lengths of row and columns are passed to nbRows
and nbCols and checked to be non-zero, memory for the element's
stiffness matrix K that is allocated;
\code
 K.resize(nbRows, nbCols, false);
 K.clear();
\endcode

Next, integration of element block stiffnes matrxi is executed, explained in
\f$\eqref {eq:StiffnessIntegral}\f$, and finally local matrix is assmble into
global stiffnes matrix as follows
\code
    // integrate local matrix for entity block
    CHKERR iNtegrate(row_data, col_data);

    // assemble local matrix
    CHKERR aSsemble(row_data, col_data);
\endcode

Lets first see the OpK::iNtegrate implementation that performs the two inner
loops described in Section \ref hierarchical_approximation_data_structures of
\ref hierarchical_approximation_1 tutorial
\code
MoFEMErrorCode iNtegrate(
      DataForcesAndSourcesCore::EntData &row_data, DataForcesAndSourcesCore::EntData &col_data)
  {
    MoFEMFunctionBegin;

    // get sub-block (3x3) of local stiffens matrix, here represented by second
    // order tensor
    auto get_tensor2 = [](MatrixDouble &m, const int r, const int c) {
      return FTensor::Tensor2<FTensor::PackPtr<double *, 3>, 3, 3>(
          &m(r + 0, c + 0), &m(r + 0, c + 1), &m(r + 0, c + 2),
          &m(r + 1, c + 0), &m(r + 1, c + 1), &m(r + 1, c + 2),
          &m(r + 2, c + 0), &m(r + 2, c + 1), &m(r + 2, c + 2));
    };

    FTensor::Index<'i', 3> i;
    FTensor::Index<'j', 3> j;
    FTensor::Index<'k', 3> k;
    FTensor::Index<'l', 3> l;

    // get element volume
    double vol = getVolume();

    // get intergrayion weights
    auto t_w = getFTensor0IntegrationWeight();

    // get derivatives of base functions on rows
    auto t_row_diff_base = row_data.getFTensor1DiffN<3>();
    // iterate over integration points
    for (int gg = 0; gg != nbIntegrationPts; ++gg) {

      // calculate scalar weight times element volume
      const double a = t_w * vol;

      // iterate over row base functions
      for (int rr = 0; rr != nbRows / 3; ++rr) {

        // get sub matrix for the row
        auto t_m = get_tensor2(K, 3 * rr, 0);

        // get derivatives of base functions for columns
        auto t_col_diff_base = col_data.getFTensor1DiffN<3>(gg, 0);

        // iterate column base functions
        for (int cc = 0; cc != nbCols / 3;++cc) {

          // integrate block local stiffens matrix
          t_m(i, k) +=
              a * (tD(i, j, k, l) * (t_row_diff_base(j) * t_col_diff_base(l)));

          // move to next column base function
          ++t_col_diff_base;

          // move to next block of local stiffens matrix
          ++t_m;
        }

        // move to next row base function
        ++t_row_diff_base;
      }

      // move to next integration weight
      ++t_w;
    }

    
    MoFEMFunctionReturn(0);
  }
\endcode
The code iterates over integration points, base functions on rows and base
functions on columns. The essential part of the code is integration itself,
\code
t_m(i, k) += a * (tD(i, j, k, l) * (t_row_diff_base(j) * t_col_diff_base(l)));
\endcode
Note that is equivalent of sub integral (\ref eq:StiffnessIntegral ). Here we
group operation in blocks using brackets, that first directives of vase
functions on rows and columns are multiplied yielding tensor of rank 2
\code
t_row_diff_base(j) * t_col_diff_base(l)
\endcode
and then the tenor of rank two is multiplied by the tenor of rank two,
yielding tensor of rank two. Resultant is multiplied by integration weight
times volume of the element and added to local element stiffnes matrix. For 
more information about tenorial operations see \ref ftenso_readme

Finally, block local stiffness matrix is assembled into global stiffness
matrix as follows
\code
  /**
     * \brief Assemble local entity block matrix
     * @param  row_data row data (consist base functions on row entity)
     * @param  col_data column data (consist base functions on column entity)
     * @return          error code
     */
  MoFEMErrorCode aSsemble(DataForcesAndSourcesCore::EntData &row_data,
                                  DataForcesAndSourcesCore::EntData &col_data) {
    MoFEMFunctionBegin;
    // get pointer to first global index on row
    const int *row_indices = &*row_data.getIndices().data().begin();
    // get pointer to first global index on column
    const int *col_indices = &*col_data.getIndices().data().begin();
    Mat B = getFEMethod()->ksp_B != PETSC_NULL ? getFEMethod()->ksp_B
                                               : getFEMethod()->snes_B;
    // assemble local matrix
    CHKERR MatSetValues(B, nbRows, row_indices, nbCols, col_indices,
                        &*K.data().begin(), ADD_VALUES);

    if (!isDiag && sYmm) {
      // if not diagonal term and since global matrix is symmetric assemble
      // transpose term.
      K = trans(K);
      CHKERR MatSetValues(B, nbCols, col_indices, nbRows, row_indices,
                          &*K.data().begin(), ADD_VALUES);
    }
    MoFEMFunctionReturn(0);
   }
\endcode

\subsection simple_elasticity_op_pressure OpPressure

The operator created for the "PRESSURE" finite element that is used to
evaluate and assign Neumann boundary conditions according to (12) presented in
\ref hierarchical_approximation_1 will be presented in detail. The operator
is the struct presented below
\code
  OpPressure(const double pressure_val = 1) :
    MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator("U", OPROW),
    pressureVal(pressure_val)
  {
  }

  //vector used to store force vector for each degree of freedom
  VectorDouble nF;

  FTensor::Index<'i', 3> i;

  MoFEMErrorCode doWork(int side, EntityType type, DataForcesAndSourcesCore::EntData &data)
  {

    MoFEMFunctionBeginHot;

   MoFEMFunctionBegin;
    // check that the faces have associated degrees of freedom
    const int nb_dofs = data.getIndices().size();
    if (nb_dofs == 0)
      MoFEMFunctionReturnHot(0);

    //size of force vector associated to the entity 
    //set equal to the number of degrees of freedom of associated with the entity
    nF.resize(nb_dofs, false);
    nF.clear();

    // get number of gauss points
    const int nb_gauss_pts = data.getN().size1();

    // create a 3d vector to be used as the normal to the face with length equal
    // to the face area
    auto t_normal = getFTensor1Normal();

    //vector of base functions 
    auto t_base = data.getFTensor0N();

    // get intergrayion weights
    auto t_w = getFTensor0IntegrationWeight();

    // loop over all gauss points of the face
    for (int gg = 0; gg != nb_gauss_pts; ++gg) {
      // weight of gg gauss point
      double w = 0.5 * t_w;

      //create a vector t_nf whose pointer points an array of 3 pointers pointing to nF 
      //memory location of components
      FTensor::Tensor1<FTensor::PackPtr<double *, 3>, 3> t_nf(&nF[0], &nF[1], &nF[2]);
      for (int bb = 0; bb != nb_dofs / 3; ++bb) {
        //scale the three components of t_normal and pass them to the t_nf (hence to nF)
        t_nf(i) += (w * pressureVal * t_base) * t_normal(i);
        //move the pointer to next element of t_nf
        ++t_nf;
        //move to next base function
        ++t_base;
      }

      // move to next integration weight
      ++t_w;
    }

    CHKERR VecSetValues(
        getFEMethod()->ksp_f, nb_dofs, &data.getIndices()[0], &nF[0], ADD_VALUES);
  
    MoFEMFunctionReturnHot(0);
  }
};
\endcode

Initially, vector \e nF that will contain the boundary condition forces is
declared and index i is defined to be used to perform compact operations
later discussed
\code
   //vector used to store force vector for each degree of freedom
  VectorDouble nF;
\endcode

The evaluation of boundary conditions for each element that are applied is
performed within the OpPressure::doWork function. The number of degrees of freedom is
initially passed to \e nb\_dofs that is used to appropriately resize vector \e nF.
\code
    //size of force vector associated to the entity 
    //set equal to the number of degrees of freedom of associated with the entity
    nF.resize(nb_dofs, false);
    nF.clear();
\endcode


Thereafter, the number of gauss points associated to the triangular element
is assigned to variable \e nb\_gauss\_pts
\code
    // get number of gauss points
    const int nb_gauss_pts = data.getN().size1();
\endcode

the normal to the face is passed to \e t\_normal variable

\code
    // create a 3d vector to be used as the normal to the face with length equal
    // to the face area
    auto t_normal = getFTensor1Normal();
\endcode 

Vector \e t\_normal has 3 component (one for each global axis). Its magnitude is
equal to the double of the area of the triangle face since
FaceElementForcesAndSourcesCore:UserDataOperator:getTensor1Norma() function
returns the vector evaluated by the cross product of the vectors having a
common origin on one of the faces vertex and their non-coinciding ends
located at the other two vertices. This product is the area defined by the
parallelogram rule.

Furthermore, \e t\_base vector containing the element's shape functions is
initialised
\code 
    //vector of base functions 
    auto t_base = data.getFTensor0N();
\endcode 

Then, the loop over all gauss points is performed to evaluate the area
integral 
\code 
    // get intergrayion weights
    auto t_w = getFTensor0IntegrationWeight();

    // loop over all gauss points of the face
    for (int gg = 0; gg != nb_gauss_pts; ++gg) {
      // weight of gg gauss point
      double w = 0.5 * t_w;

      //create a vector t_nf whose pointer points an array of 3 pointers pointing to nF 
      //memory location of components
      auto t_nf(&nF[0], &nF[1], &nF[2], 3);
      for (int bb = 0; bb != nb_dofs / 3; ++bb) {
        //scale the three components of t_normal and pass them to the t_nf (hence to nF)
        t_nf(i) += (w * pressureVal * t_base) * t_normal(i);
        //move the pointer to next element of t_nf
        ++t_nf;
        //move to next base function
        ++t_base;
      }

      // move to next integration weight
      ++t_w;
    }
\endcode 
  
In the loop, initially the weight of the gauss point is assigned to w

\code 
double w = getGaussPts()(2, gg);
\endcode 

then \e t\_nF that is a pointer to a vector is initialised in a fashion that
points to a piece of memory containing three contiguous double values that
are in this case the first three elements of the boundary condition vector
\e nF.

Since the \e t\_nF presents this structure of three contiguous elements pointed
by each pointer value, we only need to loop over a third of the number of
degrees of freedom.
\code 
  for (int bb = 0; bb != nb_dofs / 3; bb++)
\endcode 

and the within the loop for each \e t\_nF value, the corresponding block of
three members of nF can be evaluated as

\code
 t_nf(i) += (w * pressureVal * t_base) * 0.5 * t_normal(i); 
\endcode 

Index i in the last line operates the for each part of the three elements of \e nF.
So in the first instance, where bb = 0, \e nF[0], \e nF[1] and \e nF[2] are evaluated.

Thereafter, pointers \e t\_nf and \e t\_base are increased, and now they are
pointing to the next corresponding bit of memory.
\code
        ++t_nf;
        ++t_base;
\endcode 

In the second instance, where \e bb = 1, \e t\_nf(i) operates in the next three
elements of \e nF, i.e. \e nF[3], \e nF[4], \e nF[5] are evaluated and so on.

Each member of \e nF contains the surface integral presented in (12) of
``Hierarchical Approximation'' associated to the the corresponding to gauss
point gg and degree of freedom 3*bb. The product that is assigned to \e t\_nf(i)
involves multiplication of weight w of gauss point gg, the uniformly
distributed traction is a scalar pressureVal times the shape function \e t\_base
of degrees of freedom encapsulated in bb, times half the vector normal to the
surface. The halving of the vector is done to recover the face area that is
the double of the vector magnitude as describe previously.

Finally, the values passed to vector \e nF are then copied to the right hand
side vector \r ksp\_f that points to vector f presented in Section \ref
simple_elastic_solve_problem used for the solution of the system of linear
equations.

\code
ierr = VecSetValues(getFEMethod()->ksp_f, nb_dofs, &data.getIndices()[0], &nF[0], ADD_VALUES);
\endcode 
     
\subsection simple_elasticity_apply_Dir_BC ApplyDirichletBc

The class implemented to apply homogeneous Dirichlet boundary conditions
named ApplyDirichletBc is presented below
\code
struct ApplyDirichletBc : public MoFEM::FEMethod {
 
   Range fixFaces, fixNodes, fixSecondNode;
 
   ApplyDirichletBc(const Range &fix_faces, const Range &fix_nodes,
                    const Range &fix_second_node)
       : MoFEM::FEMethod(), fixFaces(fix_faces), fixNodes(fix_nodes),
         fixSecondNode(fix_second_node) {
     // constructor
   }
 
   MoFEMErrorCode postProcess() {
     MoFEMFunctionBegin;
     std::set<int> set_fix_dofs;
 
     for (_IT_NUMEREDDOF_ROW_FOR_LOOP_(problemPtr, dit)) {
       if (dit->get()->getDofCoeffIdx() == 2) {
         if (fixFaces.find(dit->get()->getEnt()) != fixFaces.end()) {
           set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
         }
       }
 
       if (fixSecondNode.find(dit->get()->getEnt()) != fixSecondNode.end()) {
         if (dit->get()->getDofCoeffIdx() == 1) {
           set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
         }
       }
 
       if (fixNodes.find(dit->get()->getEnt()) != fixNodes.end()) {
         set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
       }
     }
 
     std::vector<int> fix_dofs(set_fix_dofs.size());
     std::copy(set_fix_dofs.begin(), set_fix_dofs.end(), fix_dofs.begin());
     CHKERR MatAssemblyBegin(ksp_B, MAT_FINAL_ASSEMBLY);
     CHKERR MatAssemblyEnd(ksp_B, MAT_FINAL_ASSEMBLY);
     CHKERR VecAssemblyBegin(ksp_f);
     CHKERR VecAssemblyEnd(ksp_f);
 
     Vec x;
     CHKERR VecDuplicate(ksp_f, &x);
     CHKERR VecZeroEntries(x);

     CHKERR MatZeroRowsColumns(ksp_B, fix_dofs.size(), &fix_dofs[0], 1, x, ksp_f);
     CHKERR VecDestroy(&x);
 
     MoFEMFunctionReturn(0);
   }
 };
\endcode

Entities that were previously handled in Section \ref simple_elasticity_mesh_block 
are assigned through the constructor in public variables \e fixFaces, \e fixNodes, \e fixSecondNode

\code
   Range fixFaces, fixNodes, fixSecondNode;
 
   ApplyDirichletBc(const Range &fix_faces, const Range &fix_nodes,
                    const Range &fix_second_node)
       : MoFEM::FEMethod(), fixFaces(fix_faces), fixNodes(fix_nodes),
         fixSecondNode(fix_second_node) {
     // constructor
   }
\endcode

The homogeneous boundary conditions are then implemented in postProcess()
function. Initially, a loop over degrees of freedom is performed through
macro ``for (\_IT\_NUMEREDDOF\_ROW\_FOR\_LOOP\_(problemPtr, dit))''. Within
the loop, the degrees of freedom corresponding to the entities passed to the
public variables of the struct are inserted to vector of integers
\e set\_fix\_dofs through insert function

\code
     std::set<int> set_fix_dofs;

     for (_IT_NUMEREDDOF_ROW_FOR_LOOP_(problemPtr, dit)) {
       if (dit->get()->getDofCoeffIdx() == 2) {
         if (fixFaces.find(dit->get()->getEnt()) != fixFaces.end()) {
           set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
         }
       }
 
       if (fixSecondNode.find(dit->get()->getEnt()) != fixSecondNode.end()) {
         if (dit->get()->getDofCoeffIdx() == 1) {
           printf("The extra node \n");
           set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
         }
       }
 
       if (fixNodes.find(dit->get()->getEnt()) != fixNodes.end()) {
         set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
       }
     }
\endcode

then this data is pass to a new vector of integers \e fix\_dofs 

\code
std::vector<int> fix_dofs(set_fix_dofs.size());
std::copy(set_fix_dofs.begin(), set_fix_dofs.end(), fix_dofs.begin());
\endcode

Thereafter, the stiffness matrix \e ksp\_B and right hand side vector ksp\_f structures are constructed   
\code
     CHKERR MatAssemblyBegin(ksp_B, MAT_FINAL_ASSEMBLY);
     CHKERR MatAssemblyEnd(ksp_B, MAT_FINAL_ASSEMBLY);
     CHKERR VecAssemblyBegin(ksp_f);
     CHKERR VecAssemblyEnd(ksp_f);
\endcode

and the left hand side vector \e x is constructed by copying \e ksp\_f to \e
x and subsequently zeroing it
\code
     Vec x;
     CHKERR VecDuplicate(ksp_f, &x);
     CHKERR VecZeroEntries(x);
\endcode


Invoking function 
<a href=http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatZeroRowsColumns.html>MatZeroRowsColumns</a>
the columns and rows corresponding to
the prescribed degrees of freedom stored in fix\_dofs and the diagonal
element is set to unity and the corresponding degrees of freedom in vector x
are set to zero.

\code
    CHKERR MatZeroRowsColumns(ksp_B, fix_dofs.size(), &fix_dofs[0], 1, x, ksp_f);
\endcode

finally the memory allocated for vector \e x is freed

\code
    CHKERR VecDestroy(&x);
\endcode

\section simple_elasticity_prog_run Running the program

To run the code one should change directory to 

\code
cd $HOME/mofem_installation/users_modules/basic_finite_elements/simple_elasticity
\endcode

Then run the command

\code
./simple_elasticity -file_name simple_elasticity_part.h5m -ksp_type gmres -pc_type lu -pc_factor_mat_solver_package mumps -ksp_monitor -my_order 2
\endcode

To visualise results first convert the out put file from .h5m format to a vtk
one
\code 
mbconvert out.h5m out.vtk
\endcode

then open the .vtk file in ParaView <http://www.paraview.org>. For example 
on macOS
\code 
open out.vtk
\endcode

\ref Figure_10_displacement_result "Figure 10" shows the ParaView visualisation of the result of the considering problem.

\anchor Figure_10_displacement_result
\image html simple_elasticity_result.png "Figure 10: Result visualisation in Paraview" width = 600px

\note In the following example solution is homogenous. Thus linear
approximation is sufficient to get the exact the solution. Thus setting second
order approximation does not improve solution. Note that all DOFs on edges
for this case have zero values.

\section simple_elasticity_exercises Exercises

- Change boundary conditions to have fix cantilever and apply tractions to
bend beam in \e x or \e y direction? Check how displacements would
converge with increasing approximation order?

- Modify code to apply torsion to the beam.

- Write finite element to calculate strain energy of the beam. With that at
hand plot convergence for beam subjected bending and torsion.

If you have problems with understanding this tutorial or exercises, please
contact us on Q&A forum, see <a href=https://groups.google.com/forum/#!categories/mofem-group>link</a>.


\section mai_minimal_surface_equation The plain program

The plain program is located in \e users_modules/basic_finite_elements/simple_elasticity/simple_elasticity.cpp

\include users_modules/basic_finite_elements/simple_elasticity/simple_elasticity.cpp

*/